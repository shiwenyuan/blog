{"meta":{"title":"shiwenyuan'blog","subtitle":null,"description":"石文远的博客","author":"shiwenyuan","url":"https://shiwenyuan.github.io","root":"/"},"pages":[{"title":"about","date":"2019-08-05T06:46:52.000Z","updated":"2019-08-12T11:15:03.689Z","comments":true,"path":"about/index.html","permalink":"https://shiwenyuan.github.io/about/index.html","excerpt":"","text":"emial: stonewenyuan@gmail.com"},{"title":"categories","date":"2019-08-08T06:02:39.000Z","updated":"2019-08-08T10:36:41.985Z","comments":true,"path":"categories/index.html","permalink":"https://shiwenyuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-08T06:05:45.000Z","updated":"2019-08-08T10:36:41.987Z","comments":true,"path":"links/index.html","permalink":"https://shiwenyuan.github.io/links/index.html","excerpt":"","text":""},{"title":"books","date":"2019-08-08T06:04:56.000Z","updated":"2019-08-08T10:36:41.983Z","comments":true,"path":"books/index.html","permalink":"https://shiwenyuan.github.io/books/index.html","excerpt":"","text":""},{"title":"项目","date":"2019-08-08T10:37:20.000Z","updated":"2019-08-08T10:48:26.735Z","comments":true,"path":"repository/index.html","permalink":"https://shiwenyuan.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-08T06:37:20.000Z","updated":"2019-08-08T10:36:41.981Z","comments":true,"path":"tags/index.html","permalink":"https://shiwenyuan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP-多进程之孤儿和僵尸简单讲解","slug":"PHP-多进程之孤儿和僵尸简单讲解","date":"2019-08-07T09:42:13.000Z","updated":"2019-08-08T10:08:12.169Z","comments":true,"path":"posts/cjzhzee5h0000sbs6ejawbwe2.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee5h0000sbs6ejawbwe2.html","excerpt":"","text":"PHP 多进程之孤儿 / 僵尸whatinit 进程普通用户运行但有超级权限的进程 孤儿进程父进程在子进程处理完前退出， 子进程就会变成孤儿进程；并由 init 进程进行处理 僵尸进程 「z+」标记 父进程 fork 子进程后， 没有调用 wait 来维护子进程，导致子进程无人管理 why总是不断 fork， 不管维护。系统资源有限 – 就会出现僵尸进程 how相比孤儿进程，僵尸进程危害更大，毕竟孤儿还有 init 妈妈来抚养，僵尸就只能独自游荡！ pcntl_waitpcntl_waitpid 等待或返回 fork 的子进程状态 相同pcntl_wait($status, $option) == pcntl_waitpid(-1, $status, $option)pcntl_waitpid($pid, $status, $option) pid&lt;-1: 等待任意进程组 ID 等于参数 pid 给定值的绝对值的进程-1: 等待任意子进程；与 pcntl_wait 函数行为一致0: 等待任意与调用进程组 ID 相同的子进程 10: 等待进程号等于参数 pid 值的子进程 optionWNOHANG: 如果没有子进程退出立刻返回WUNTRACED: 子进程已经退出并且其状态未报告时返回 孤儿进程12345678910111213141516171819202122232425262728&lt;?php$pid = pcntl_fork();switch($pid) &#123; case 0: // 子进程 echo \"I am son parent's pid=\".posix_getppid().\"\\n\"; for( $i = 1; $i &lt;= 10; $i++ )&#123; sleep( 1 ); // posix_getppid()函数的作用就是获取当前进程的父进程进程ID echo \"parent's pid =\" posix_getppid().PHP_EOL; &#125; break; case -1: // fork error echo \"I am err\\n\"; break; default: // 父进程 echo \"I am parent pid=\".posix_getpid().\"\\n\"; sleep(2); break;&#125;// 第三秒后 由init进程收养 僵尸进程1234567891011121314151617181920&lt;?php$pid = pcntl_fork();switch($pid) &#123; case 0: // 子进程 cli_set_process_title(\"son process php\"); sleep(5); break; case -1: // fork error break; default: // 父进程 cli_set_process_title(\"parent process php\"); sleep(30); break;&#125;// 子进程执行后父进程未取管理导致 解决12345678910111213141516171819202122232425262728&lt;?phpswitch($pid) &#123; case 0: // 子进程 cli_set_process_title(\"son process php\"); sleep(10); break; case -1: // fork error break; default: // 父进程 cli_set_process_title(\"parent process php\"); $iid = pcntl_wait($status); // 等待子进程的状态处理 // 监控子进程状态处理后才能输出 // 只要未触发pcntl_wait，此后的逻辑一直不会处理 echo $iid.\"-----\\n\"; //sleep(60); break;&#125;===// 增加pcntl_wait// pcntl_wait($status); // 只要子进程不退出， 父进程就会阻塞再这个地方 更优解决123456789101112131415161718192021222324252627&lt;?php$pid = pcntl_fork();switch($pid) &#123; case 0: // 子进程 cli_set_process_title(\"son process php\"); sleep(10); break; case -1: // fork error break; default: // 父进程 cli_set_process_title(\"parent process php\"); pcntl_waitpid($pid, $status, WNOHANG); // 监控$pid， 如果没有子进程退出立刻返回 echo \"I am parent\\n\"; //sleep(60); break;&#125;===// pcntl_wait改写pcntl_waitpid// pcntl_waitpid($pid, $status, WNOHANG); // 如果再pcntl_waitpid后续增加sleep， 还是会僵尸进程 更更优解决1信号","categories":[{"name":"linux","slug":"linux","permalink":"https://shiwenyuan.github.io/categories/linux/"}],"tags":[{"name":"php","slug":"php","permalink":"https://shiwenyuan.github.io/tags/php/"},{"name":"linux","slug":"linux","permalink":"https://shiwenyuan.github.io/tags/linux/"}]},{"title":"PHP-代码整洁之道","slug":"PHP-代码整洁之道","date":"2019-08-07T09:42:13.000Z","updated":"2019-08-19T06:03:23.183Z","comments":true,"path":"posts/cjzhzeeal002bsbs6bdrrb2mc.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzeeal002bsbs6bdrrb2mc.html","excerpt":"","text":"前言 文章出处 https://github.com/php-cpm/clean-code-php Clean Code PHP目录 介绍 变量 使用见字知意的变量名 同一个实体要用相同的变量名 使用便于搜索的名称 (part 1) 使用便于搜索的名称 (part 2) 使用自解释型变量 避免深层嵌套，尽早返回 (part 1) 避免深层嵌套，尽早返回 (part 2) 少用无意义的变量名 不要添加不必要上下文 合理使用参数默认值，没必要在方法里再做默认值检测 表达式 使用恒等式 函数 函数参数（最好少于2个） 函数应该只做一件事 函数名应体现他做了什么事 函数里应当只有一层抽象abstraction 不要用flag作为函数的参数 避免副作用 不要写全局函数 不要使用单例模式 封装条件语句 避免用反义条件判断 避免条件判断 避免类型检查 (part 1) 避免类型检查 (part 2) 移除僵尸代码 对象和数据结构 Objects and Data Structures 使用 getters 和 setters Use object encapsulation 给对象使用私有或受保护的成员变量 类 少用继承多用组合 避免连贯接口 推荐使用 final 类 类的SOLID原则 SOLID S: 单一职责原则 Single Responsibility Principle (SRP) O: 开闭原则 Open/Closed Principle (OCP) L: 里氏替换原则 Liskov Substitution Principle (LSP) I: 接口隔离原则 Interface Segregation Principle (ISP) D: 依赖倒置原则 Dependency Inversion Principle (DIP) 别写重复代码 (DRY) 翻译 介绍本文参考自 Robert C. Martin的Clean Code 书中的软件工程师的原则,适用于PHP。 这不是风格指南。 这是一个关于开发可读、可复用并且可重构的PHP软件指南。 并不是这里所有的原则都得遵循，甚至很少的能被普遍接受。 这些虽然只是指导，但是都是Clean Code作者多年总结出来的。 本文受到 clean-code-javascript 的启发 虽然很多开发者还在使用PHP5，但是本文中的大部分示例的运行环境需要PHP 7.1+。 翻译说明翻译完成度100%，最后更新时间2017-12-25。本文由 php-cpm 基于 yangweijie版本 的clean-code-php翻译并同步大量原文内容。 原文更新频率较高，我的翻译方法是直接用文本比较工具逐行对比。优先保证文字内容是最新的，再逐步提升翻译质量。 阅读过程中如果遇到各种链接失效、内容老旧、术语使用错误和其他翻译错误等问题，欢迎大家积极提交PR。 变量使用见字知意的变量名坏: 1$ymdstr = $moment-&gt;format('y-m-d'); 好: 1$currentDate = $moment-&gt;format('y-m-d'); ⬆ 返回顶部 同一个实体要用相同的变量名坏: 1234getUserInfo();getUserData();getUserRecord();getUserProfile(); 好: 1getUser(); ⬆ 返回顶部 使用便于搜索的名称 (part 1)写代码是用来读的。所以写出可读性高、便于搜索的代码至关重要。命名变量时如果没有有意义、不好理解，那就是在伤害读者。请让你的代码便于搜索。 坏: 12// What the heck is 448 for?$result = $serializer-&gt;serialize($data, 448); 好: 1$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE); 使用便于搜索的名称 (part 2)坏: 1234// What the heck is 4 for?if ($user-&gt;access &amp; 4) &#123; // ...&#125; 好: 1234567891011class User&#123; const ACCESS_READ = 1; const ACCESS_CREATE = 2; const ACCESS_UPDATE = 4; const ACCESS_DELETE = 8;&#125;if ($user-&gt;access &amp; User::ACCESS_UPDATE) &#123; // do edit ...&#125; ⬆ 返回顶部 使用自解释型变量坏: 12345$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\\s*(.+?)\\s*(\\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches[1], $matches[2]); 不错: 好一些，但强依赖于正则表达式的熟悉程度 123456$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\\s*(.+?)\\s*(\\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);[, $city, $zipCode] = $matches;saveCityZipCode($city, $zipCode); 好: 使用带名字的子规则，不用懂正则也能看的懂 12345$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\\s*(?&lt;city&gt;.+?)\\s*(?&lt;zipCode&gt;\\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches['city'], $matches['zipCode']); ⬆ 返回顶部 避免深层嵌套，尽早返回 (part 1)太多的if else语句通常会导致你的代码难以阅读，直白优于隐晦 糟糕: 123456789101112131415161718192021function isShopOpen($day): bool&#123; if ($day) &#123; if (is_string($day)) &#123; $day = strtolower($day); if ($day === 'friday') &#123; return true; &#125; elseif ($day === 'saturday') &#123; return true; &#125; elseif ($day === 'sunday') &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; 好: 123456789101112function isShopOpen(string $day): bool&#123; if (empty($day)) &#123; return false; &#125; $openingDays = [ 'friday', 'saturday', 'sunday' ]; return in_array(strtolower($day), $openingDays, true);&#125; ⬆ 返回顶部 避免深层嵌套，尽早返回 (part 2)糟糕的: 12345678910111213141516function fibonacci(int $n)&#123; if ($n &lt; 50) &#123; if ($n !== 0) &#123; if ($n !== 1) &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; return 'Not supported'; &#125;&#125; 好: 123456789101112function fibonacci(int $n): int&#123; if ($n === 0 || $n === 1) &#123; return $n; &#125; if ($n &gt; 50) &#123; throw new \\Exception('Not supported'); &#125; return fibonacci($n - 1) + fibonacci($n - 2);&#125; ⬆ 返回顶部 少用无意义的变量名别让读你的代码的人猜你写的变量是什么意思。写清楚好过模糊不清。 坏: 123456789101112$l = ['Austin', 'New York', 'San Francisco'];for ($i = 0; $i &lt; count($l); $i++) &#123; $li = $l[$i]; doStuff(); doSomeOtherStuff(); // ... // ... // ... // 等等, `$li` 又代表什么? dispatch($li);&#125; 好: 12345678910$locations = ['Austin', 'New York', 'San Francisco'];foreach ($locations as $location) &#123; doStuff(); doSomeOtherStuff(); // ... // ... // ... dispatch($location);&#125; ⬆ 返回顶部 不要添加不必要上下文如果从你的类名、对象名已经可以得知一些信息，就别再在变量名里重复。 坏: 12345678class Car&#123; public $carMake; public $carModel; public $carColor; //...&#125; 好: 12345678class Car&#123; public $make; public $model; public $color; //...&#125; ⬆ 返回顶部 合理使用参数默认值，没必要在方法里再做默认值检测不好: 不好，$breweryName 可能为 NULL. 1234function createMicrobrewery($breweryName = 'Hipster Brew Co.'): void&#123; // ...&#125; 还行: 比上一个好理解一些，但最好能控制变量的值 12345function createMicrobrewery($name = null): void&#123; $breweryName = $name ?: 'Hipster Brew Co.'; // ...&#125; 好: 如果你的程序只支持 PHP 7+, 那你可以用 type hinting 保证变量 $breweryName 不是 NULL. 1234function createMicrobrewery(string $breweryName = 'Hipster Brew Co.'): void&#123; // ...&#125; ⬆ 返回顶部 表达式使用恒等式不好: 简易对比会将字符串转为整形 123456$a = '42';$b = 42;if( $a != $b ) &#123; //这里始终执行不到&#125; 对比 $a != $b 返回了 FALSE 但应该返回 TRUE !字符串 ‘42’ 跟整数 42 不相等 好: 使用恒等判断检查类型和数据 123456$a = '42';$b = 42;if ($a !== $b) &#123; // The expression is verified&#125; The comparison $a !== $b returns TRUE. ⬆ 返回顶部 函数函数参数（最好少于2个）限制函数参数个数极其重要，这样测试你的函数容易点。有超过3个可选参数参数导致一个爆炸式组合增长，你会有成吨独立参数情形要测试。 无参数是理想情况。1个或2个都可以，最好避免3个。再多就需要加固了。通常如果你的函数有超过两个参数，说明他要处理的事太多了。 如果必须要传入很多数据，建议封装一个高级别对象作为参数。 坏: 1234function createMenu(string $title, string $body, string $buttonText, bool $cancellable): void&#123; // ...&#125; 好: 123456789101112131415161718class MenuConfig&#123; public $title; public $body; public $buttonText; public $cancellable = false;&#125;$config = new MenuConfig();$config-&gt;title = 'Foo';$config-&gt;body = 'Bar';$config-&gt;buttonText = 'Baz';$config-&gt;cancellable = true;function createMenu(MenuConfig $config): void&#123; // ...&#125; ⬆ 返回顶部 函数应该只做一件事这是迄今为止软件工程里最重要的一个规则。当一个函数做超过一件事的时候，他们就难于实现、测试和理解。当你把一个函数拆分到只剩一个功能时，他们就容易被重构，然后你的代码读起来就更清晰。如果你光遵循这条规则，你就领先于大多数开发者了。 坏: 123456789function emailClients(array $clients): void&#123; foreach ($clients as $client) &#123; $clientRecord = $db-&gt;find($client); if ($clientRecord-&gt;isActive()) &#123; email($client); &#125; &#125;&#125; 好: 1234567891011121314151617function emailClients(array $clients): void&#123; $activeClients = activeClients($clients); array_walk($activeClients, 'email');&#125;function activeClients(array $clients): array&#123; return array_filter($clients, 'isClientActive');&#125;function isClientActive(int $client): bool&#123; $clientRecord = $db-&gt;find($client); return $clientRecord-&gt;isActive();&#125; ⬆ 返回顶部 函数名应体现他做了什么事坏: 12345678910111213class Email&#123; //... public function handle(): void &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 啥？handle处理一个消息干嘛了？是往一个文件里写吗？$message-&gt;handle(); 好: 12345678910111213class Email &#123; //... public function send(): void &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 简单明了$message-&gt;send(); ⬆ 返回顶部 函数里应当只有一层抽象abstraction当你抽象层次过多时时，函数处理的事情太多了。需要拆分功能来提高可重用性和易用性，以便简化测试。（译者注：这里从示例代码看应该是指嵌套过多） 坏: 1234567891011121314151617181920212223function parseBetterJSAlternative(string $code): void&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; // ... &#125; &#125; $ast = []; foreach ($tokens as $token) &#123; // lex... &#125; foreach ($ast as $node) &#123; // parse... &#125;&#125; 坏: 我们把一些方法从循环中提取出来，但是parseBetterJSAlternative()方法还是很复杂，而且不利于测试。 1234567891011121314151617181920212223242526272829303132333435function tokenize(string $code): array&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens;&#125;function lexer(array $tokens): array&#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast;&#125;function parseBetterJSAlternative(string $code): void&#123; $tokens = tokenize($code); $ast = lexer($tokens); foreach ($ast as $node) &#123; // 解析逻辑... &#125;&#125; 好: 最好的解决方案是把 parseBetterJSAlternative()方法的依赖移除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Tokenizer&#123; public function tokenize(string $code): array &#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens; &#125;&#125;class Lexer&#123; public function lexify(array $tokens): array &#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast; &#125;&#125;class BetterJSAlternative&#123; private $tokenizer; private $lexer; public function __construct(Tokenizer $tokenizer, Lexer $lexer) &#123; $this-&gt;tokenizer = $tokenizer; $this-&gt;lexer = $lexer; &#125; public function parse(string $code): void &#123; $tokens = $this-&gt;tokenizer-&gt;tokenize($code); $ast = $this-&gt;lexer-&gt;lexify($tokens); foreach ($ast as $node) &#123; // 解析逻辑... &#125; &#125;&#125; 这样我们可以对依赖做mock，并测试BetterJSAlternative::parse()运行是否符合预期。 ⬆ 返回顶部 不要用flag作为函数的参数flag就是在告诉大家，这个方法里处理很多事。前面刚说过，一个函数应当只做一件事。 把不同flag的代码拆分到多个函数里。 坏: 12345678function createFile(string $name, bool $temp = false): void&#123; if ($temp) &#123; touch('./temp/'.$name); &#125; else &#123; touch($name); &#125;&#125; 好: 123456789function createFile(string $name): void&#123; touch($name);&#125;function createTempFile(string $name): void&#123; touch('./temp/'.$name);&#125; ⬆ 返回顶部 避免副作用一个函数做了比获取一个值然后返回另外一个值或值们会产生副作用如果。副作用可能是写入一个文件，修改某些全局变量或者偶然的把你全部的钱给了陌生人。 现在，你的确需要在一个程序或者场合里要有副作用，像之前的例子，你也许需要写一个文件。你想要做的是把你做这些的地方集中起来。不要用几个函数和类来写入一个特定的文件。用一个服务来做它，一个只有一个。 重点是避免常见陷阱比如对象间共享无结构的数据，使用可以写入任何的可变数据类型，不集中处理副作用发生的地方。如果你做了这些你就会比大多数程序员快乐。 坏: 1234567891011121314// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.$name = 'Ryan McDermott';function splitIntoFirstAndLastName(): void&#123; global $name; $name = explode(' ', $name);&#125;splitIntoFirstAndLastName();var_dump($name); // ['Ryan', 'McDermott']; 好: 12345678910function splitIntoFirstAndLastName(string $name): array&#123; return explode(' ', $name);&#125;$name = 'Ryan McDermott';$newName = splitIntoFirstAndLastName($name);var_dump($name); // 'Ryan McDermott';var_dump($newName); // ['Ryan', 'McDermott']; ⬆ 返回顶部 不要写全局函数在大多数语言中污染全局变量是一个坏的实践，因为你可能和其他类库冲突并且调用你api的人直到他们捕获异常才知道踩坑了。让我们思考一种场景：如果你想配置一个数组，你可能会写一个全局函数config()，但是他可能和试着做同样事的其他类库冲突。 坏: 123456function config(): array&#123; return [ 'foo' =&gt; 'bar', ]&#125; 好: 1234567891011121314class Configuration&#123; private $configuration = []; public function __construct(array $configuration) &#123; $this-&gt;configuration = $configuration; &#125; public function get(string $key): ?string &#123; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null; &#125;&#125; 加载配置并创建 Configuration 类的实例 123$configuration = new Configuration([ 'foo' =&gt; 'bar',]); 现在你必须在程序中用 Configuration 的实例了 ⬆ 返回顶部 不要使用单例模式单例是一种 反模式. 以下是解释：Paraphrased from Brian Button: 总是被用成全局实例。They are generally used as a global instance, why is that so bad? Because you hide the dependencies of your application in your code, instead of exposing them through the interfaces. Making something global to avoid passing it around is a code smell. 违反了单一响应原则They violate the single responsibility principle: by virtue of the fact that they control their own creation and lifecycle. 导致代码强耦合They inherently cause code to be tightly coupled. This makes faking them out under test rather difficult in many cases. 在整个程序的生命周期中始终携带状态。They carry state around for the lifetime of the application. Another hit to testing since you can end up with a situation where tests need to be ordered which is a big no for unit tests. Why? Because each unit test should be independent from the other. 这里有一篇非常好的讨论单例模式的[根本问题((http://misko.hevery.com/2008/08/25/root-cause-of-singletons/)的文章，是[Misko Hevery](http://misko.hevery.com/about/) 写的。 坏: 12345678910111213141516171819202122class DBConnection&#123; private static $instance; private function __construct(string $dsn) &#123; // ... &#125; public static function getInstance(): DBConnection &#123; if (self::$instance === null) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; // ...&#125;$singleton = DBConnection::getInstance(); 好: 123456789class DBConnection&#123; public function __construct(string $dsn) &#123; // ... &#125; // ...&#125; 创建 DBConnection 类的实例并通过 DSN 配置. 1$connection = new DBConnection($dsn); 现在你必须在程序中 使用 DBConnection 的实例了 ⬆ 返回顶部 封装条件语句坏: 123if ($article-&gt;state === 'published') &#123; // ...&#125; 好: 123if ($article-&gt;isPublished()) &#123; // ...&#125; ⬆ 返回顶部 避免用反义条件判断坏: 123456789function isDOMNodeNotPresent(\\DOMNode $node): bool&#123; // ...&#125;if (!isDOMNodeNotPresent($node))&#123; // ...&#125; 好: 12345678function isDOMNodePresent(\\DOMNode $node): bool&#123; // ...&#125;if (isDOMNodePresent($node)) &#123; // ...&#125; ⬆ 返回顶部 避免条件判断这看起来像一个不可能任务。当人们第一次听到这句话是都会这么说。“没有if语句我还能做啥？” 答案是你可以使用多态来实现多种场景的相同任务。第二个问题很常见， “这么做可以，但为什么我要这么做？” 答案是前面我们学过的一个Clean Code原则：一个函数应当只做一件事。 当你有很多含有if语句的类和函数时,你的函数做了不止一件事。 记住，只做一件事。 坏: 12345678910111213141516class Airplane&#123; // ... public function getCruisingAltitude(): int &#123; switch ($this-&gt;type) &#123; case '777': return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); case 'Air Force One': return $this-&gt;getMaxAltitude(); case 'Cessna': return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125; &#125;&#125; 好: 123456789101112131415161718192021222324252627282930313233343536interface Airplane&#123; // ... public function getCruisingAltitude(): int;&#125;class Boeing777 implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); &#125;&#125;class AirForceOne implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude(); &#125;&#125;class Cessna implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125;&#125; ⬆ 返回顶部 避免类型检查 (part 1)PHP是弱类型的,这意味着你的函数可以接收任何类型的参数。有时候你为这自由所痛苦并且在你的函数渐渐尝试类型检查。有很多方法去避免这么做。第一种是统一API。 坏: 12345678function travelToTexas($vehicle): void&#123; if ($vehicle instanceof Bicycle) &#123; $vehicle-&gt;pedalTo(new Location('texas')); &#125; elseif ($vehicle instanceof Car) &#123; $vehicle-&gt;driveTo(new Location('texas')); &#125;&#125; 好: 1234function travelToTexas(Traveler $vehicle): void&#123; $vehicle-&gt;travelTo(new Location('texas'));&#125; ⬆ 返回顶部 避免类型检查 (part 2)如果你正使用基本原始值比如字符串、整形和数组，要求版本是PHP 7+，不用多态，需要类型检测，那你应当考虑类型声明或者严格模式。提供了基于标准PHP语法的静态类型。 手动检查类型的问题是做好了需要好多的废话，好像为了安全就可以不顾损失可读性。保持你的PHP 整洁，写好测试，做好代码回顾。做不到就用PHP严格类型声明和严格模式来确保安全。 坏: 12345678function combine($val1, $val2): int&#123; if (!is_numeric($val1) || !is_numeric($val2)) &#123; throw new \\Exception('Must be of type Number'); &#125; return $val1 + $val2;&#125; 好: 1234function combine(int $val1, int $val2): int&#123; return $val1 + $val2;&#125; ⬆ 返回顶部 移除僵尸代码僵尸代码和重复代码一样坏。没有理由保留在你的代码库中。如果从来没被调用过，就删掉！因为还在代码版本库里，因此很安全。 坏: 123456789101112function oldRequestModule(string $url): void&#123; // ...&#125;function newRequestModule(string $url): void&#123; // ...&#125;$request = newRequestModule($requestUrl);inventoryTracker('apples', $request, 'www.inventory-awesome.io'); 好: 1234567function requestModule(string $url): void&#123; // ...&#125;$request = requestModule($requestUrl);inventoryTracker('apples', $request, 'www.inventory-awesome.io'); ⬆ 返回顶部 对象和数据结构使用 getters 和 setters在PHP中你可以对方法使用public, protected, private 来控制对象属性的变更。 当你想对对象属性做获取之外的操作时，你不需要在代码中去寻找并修改每一个该属性访问方法 当有set对应的属性方法时，易于增加参数的验证 封装内部的表示 使用set和get时，易于增加日志和错误控制 继承当前类时，可以复写默认的方法功能 当对象属性是从远端服务器获取时，get，set易于使用延迟加载 此外，这样的方式也符合OOP开发中的开闭原则 坏: 123456789class BankAccount&#123; public $balance = 1000;&#125;$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;balance -= 100; 好: 123456789101112131415161718192021222324252627282930313233343536class BankAccount&#123; private $balance; public function __construct(int $balance = 1000) &#123; $this-&gt;balance = $balance; &#125; public function withdraw(int $amount): void &#123; if ($amount &gt; $this-&gt;balance) &#123; throw new \\Exception('Amount greater than available balance.'); &#125; $this-&gt;balance -= $amount; &#125; public function deposit(int $amount): void &#123; $this-&gt;balance += $amount; &#125; public function getBalance(): int &#123; return $this-&gt;balance; &#125;&#125;$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;withdraw($shoesPrice);// Get balance$balance = $bankAccount-&gt;getBalance(); ⬆ 返回顶部 给对象使用私有或受保护的成员变量 对public方法和属性进行修改非常危险，因为外部代码容易依赖他，而你没办法控制。对之修改影响所有这个类的使用者。 public methods and properties are most dangerous for changes, because some outside code may easily rely on them and you can’t control what code relies on them. Modifications in class are dangerous for all users of class. 对protected的修改跟对public修改差不多危险，因为他们对子类可用，他俩的唯一区别就是可调用的位置不一样，对之修改影响所有集成这个类的地方。 protected modifier are as dangerous as public, because they are available in scope of any child class. This effectively means that difference between public and protected is only in access mechanism, but encapsulation guarantee remains the same. Modifications in class are dangerous for all descendant classes. 对private的修改保证了这部分代码只会影响当前类private modifier guarantees that code is dangerous to modify only in boundaries of single class (you are safe for modifications and you won’t have Jenga effect). 所以，当你需要控制类里的代码可以被访问时才用public/protected，其他时候都用private。 可以读一读这篇 博客文章 ，Fabien Potencier写的. 坏: 123456789101112class Employee&#123; public $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;name; // Employee name: John Doe 好: 1234567891011121314151617class Employee&#123; private $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125; public function getName(): string &#123; return $this-&gt;name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;getName(); // Employee name: John Doe ⬆ 返回顶部 类少用继承多用组合正如 the Gang of Four 所著的设计模式之前所说，我们应该尽量优先选择组合而不是继承的方式。使用继承和组合都有很多好处。这个准则的主要意义在于当你本能的使用继承时，试着思考一下组合是否能更好对你的需求建模。在一些情况下，是这样的。 接下来你或许会想，“那我应该在什么时候使用继承？”答案依赖于你的问题，当然下面有一些何时继承比组合更好的说明： 你的继承表达了“是一个”而不是“有一个”的关系（人类-》动物，用户-》用户详情） 你可以复用基类的代码（人类可以像动物一样移动） 你想通过修改基类对所有派生类做全局的修改（当动物移动时，修改她们的能量消耗） 糟糕的: 12345678910111213141516171819202122232425262728293031323334class Employee &#123; private $name; private $email; public function __construct(string $name, string $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; // ...&#125;// 不好，因为 Employees \"有\" taxdata// 而 EmployeeTaxData 不是 Employee 类型的class EmployeeTaxData extends Employee &#123; private $ssn; private $salary; public function __construct(string $name, string $email, string $ssn, string $salary) &#123; parent::__construct($name, $email); $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125; 好: 123456789101112131415161718192021222324252627282930313233class EmployeeTaxData &#123; private $ssn; private $salary; public function __construct(string $ssn, string $salary) &#123; $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125;class Employee &#123; private $name; private $email; private $taxData; public function __construct(string $name, string $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function setTaxData(string $ssn, string $salary) &#123; $this-&gt;taxData = new EmployeeTaxData($ssn, $salary); &#125; // ...&#125; ⬆ 返回顶部 避免连贯接口连贯接口Fluent interface是一种旨在提高面向对象编程时代码可读性的API设计模式，他基于方法链Method chaining 有上下文的地方可以降低代码复杂度，例如PHPUnit Mock Builder和Doctrine Query Builder，更多的情况会带来较大代价： While there can be some contexts, frequently builder objects, where thispattern reduces the verbosity of the code (for example the PHPUnit Mock Builderor the Doctrine Query Builder),more often it comes at some costs: 破坏了 对象封装 破坏了 装饰器模式 在测试组件中不好做mock 导致提交的diff不好阅读 了解更多请阅读 连贯接口为什么不好，作者 Marco Pivetta. 坏: 1234567891011121314151617181920212223242526272829303132333435363738394041class Car&#123; private $make = 'Honda'; private $model = 'Accord'; private $color = 'white'; public function setMake(string $make): self &#123; $this-&gt;make = $make; // NOTE: Returning this for chaining return $this; &#125; public function setModel(string $model): self &#123; $this-&gt;model = $model; // NOTE: Returning this for chaining return $this; &#125; public function setColor(string $color): self &#123; $this-&gt;color = $color; // NOTE: Returning this for chaining return $this; &#125; public function dump(): void &#123; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color); &#125;&#125;$car = (new Car()) -&gt;setColor('pink') -&gt;setMake('Ford') -&gt;setModel('F-150') -&gt;dump(); 好: 1234567891011121314151617181920212223242526272829303132class Car&#123; private $make = 'Honda'; private $model = 'Accord'; private $color = 'white'; public function setMake(string $make): void &#123; $this-&gt;make = $make; &#125; public function setModel(string $model): void &#123; $this-&gt;model = $model; &#125; public function setColor(string $color): void &#123; $this-&gt;color = $color; &#125; public function dump(): void &#123; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color); &#125;&#125;$car = new Car();$car-&gt;setColor('pink');$car-&gt;setMake('Ford');$car-&gt;setModel('F-150');$car-&gt;dump(); ⬆ 返回顶部 推荐使用 final 类能用时尽量使用 final 关键字: 阻止不受控的继承链 鼓励 组合. 鼓励 单一职责模式. 鼓励开发者用你的公开方法而非通过继承类获取受保护方法的访问权限. 使得在不破坏使用你的类的应用的情况下修改代码成为可能. The only condition is that your class should implement an interface and no other public methods are defined. For more informations you can read the blog post on this topic written by Marco Pivetta (Ocramius). Bad: 1234567891011121314151617final class Car&#123; private $color; public function __construct($color) &#123; $this-&gt;color = $color; &#125; /** * @return string The color of the vehicle */ public function getColor() &#123; return $this-&gt;color; &#125;&#125; Good: 12345678910111213141516171819202122232425interface Vehicle&#123; /** * @return string The color of the vehicle */ public function getColor();&#125;final class Car implements Vehicle&#123; private $color; public function __construct($color) &#123; $this-&gt;color = $color; &#125; /** * &#123;@inheritdoc&#125; */ public function getColor() &#123; return $this-&gt;color; &#125;&#125; ⬆ 返回顶部 SOLIDSOLID 是Michael Feathers推荐的便于记忆的首字母简写，它代表了Robert Martin命名的最重要的五个面对对象编码设计原则 S: 单一职责原则 (SRP) O: 开闭原则 (OCP) L: 里氏替换原则 (LSP) I: 接口隔离原则 (ISP) D: 依赖倒置原则 (DIP) 单一职责原则Single Responsibility Principle (SRP) 正如在Clean Code所述，”修改一个类应该只为一个理由”。人们总是易于用一堆方法塞满一个类，如同我们只能在飞机上只能携带一个行李箱（把所有的东西都塞到箱子里）。这样做的问题是：从概念上这样的类不是高内聚的，并且留下了很多理由去修改它。将你需要修改类的次数降低到最小很重要。这是因为，当有很多方法在类中时，修改其中一处，你很难知晓在代码库中哪些依赖的模块会被影响到。 坏: 123456789101112131415161718192021class UserSettings&#123; private $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function changeSettings(array $settings): void &#123; if ($this-&gt;verifyCredentials()) &#123; // ... &#125; &#125; private function verifyCredentials(): bool &#123; // ... &#125;&#125; 好: 123456789101112131415161718192021222324252627282930313233class UserAuth &#123; private $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function verifyCredentials(): bool &#123; // ... &#125;&#125;class UserSettings &#123; private $user; private $auth; public function __construct(User $user) &#123; $this-&gt;user = $user; $this-&gt;auth = new UserAuth($user); &#125; public function changeSettings(array $settings): void &#123; if ($this-&gt;auth-&gt;verifyCredentials()) &#123; // ... &#125; &#125;&#125; ⬆ 返回顶部 开闭原则Open/Closed Principle (OCP) 正如Bertrand Meyer所述，”软件的工件（ classes, modules, functions 等）应该对扩展开放，对修改关闭。” 然而这句话意味着什么呢？这个原则大体上表示你应该允许在不改变已有代码的情况下增加新的功能 坏: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960abstract class Adapter&#123; protected $name; public function getName(): string &#123; return $this-&gt;name; &#125;&#125;class AjaxAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'ajaxAdapter'; &#125;&#125;class NodeAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'nodeAdapter'; &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch(string $url): Promise &#123; $adapterName = $this-&gt;adapter-&gt;getName(); if ($adapterName === 'ajaxAdapter') &#123; return $this-&gt;makeAjaxCall($url); &#125; elseif ($adapterName === 'httpNodeAdapter') &#123; return $this-&gt;makeHttpCall($url); &#125; &#125; private function makeAjaxCall(string $url): Promise &#123; // request and return promise &#125; private function makeHttpCall(string $url): Promise &#123; // request and return promise &#125;&#125; 好: 1234567891011121314151617181920212223242526272829303132333435interface Adapter&#123; public function request(string $url): Promise;&#125;class AjaxAdapter implements Adapter&#123; public function request(string $url): Promise &#123; // request and return promise &#125;&#125;class NodeAdapter implements Adapter&#123; public function request(string $url): Promise &#123; // request and return promise &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch(string $url): Promise &#123; return $this-&gt;adapter-&gt;request($url); &#125;&#125; ⬆ 返回顶部 里氏替换原则Liskov Substitution Principle (LSP) 这是一个简单的原则，却用了一个不好理解的术语。它的正式定义是“如果S是T的子类型，那么在不改变程序原有既定属性（检查、执行任务等）的前提下，任何T类型的对象都可以使用S类型的对象替代（例如，使用S的对象可以替代T的对象）” 这个定义更难理解:-)。 对这个概念最好的解释是：如果你有一个父类和一个子类，在不改变原有结果正确性的前提下父类和子类可以互换。这个听起来依旧让人有些迷惑，所以让我们来看一个经典的正方形-长方形的例子。从数学上讲，正方形是一种长方形，但是当你的模型通过继承使用了”is-a”的关系时，就不对了。 坏: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Rectangle&#123; protected $width = 0; protected $height = 0; public function setWidth(int $width): void &#123; $this-&gt;width = $width; &#125; public function setHeight(int $height): void &#123; $this-&gt;height = $height; &#125; public function getArea(): int &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Rectangle&#123; public function setWidth(int $width): void &#123; $this-&gt;width = $this-&gt;height = $width; &#125; public function setHeight(int $height): void &#123; $this-&gt;width = $this-&gt;height = $height; &#125;&#125;function printArea(Rectangle $rectangle): void&#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); // BAD: Will return 25 for Square. Should be 20. echo sprintf('%s has area %d.', get_class($rectangle), $rectangle-&gt;getArea()).PHP_EOL;&#125;$rectangles = [new Rectangle(), new Square()];foreach ($rectangles as $rectangle) &#123; printArea($rectangle);&#125; 好: 最好是将这两种四边形分别对待，用一个适合两种类型的更通用子类型来代替。 尽管正方形和长方形看起来很相似，但他们是不同的。正方形更接近菱形，而长方形更接近平行四边形。但他们不是子类型。尽管相似，正方形、长方形、菱形、平行四边形都是有自己属性的不同形状。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface Shape&#123; public function getArea(): int;&#125;class Rectangle implements Shape&#123; private $width = 0; private $height = 0; public function __construct(int $width, int $height) &#123; $this-&gt;width = $width; $this-&gt;height = $height; &#125; public function getArea(): int &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square implements Shape&#123; private $length = 0; public function __construct(int $length) &#123; $this-&gt;length = $length; &#125; public function getArea(): int &#123; return $this-&gt;length ** 2; &#125;&#125;function printArea(Shape $shape): void&#123; echo sprintf('%s has area %d.', get_class($shape), $shape-&gt;getArea()).PHP_EOL;&#125;$shapes = [new Rectangle(4, 5), new Square(5)];foreach ($shapes as $shape) &#123; printArea($shape);&#125; ⬆ 返回顶部 接口隔离原则Interface Segregation Principle (ISP) 接口隔离原则表示：”调用方不应该被强制依赖于他不需要的接口” 有一个清晰的例子来说明示范这条原则。当一个类需要一个大量的设置项，为了方便不会要求调用方去设置大量的选项，因为在通常他们不需要所有的设置项。使设置项可选有助于我们避免产生”胖接口” 坏: 1234567891011121314151617181920212223242526272829303132interface Employee&#123; public function work(): void; public function eat(): void;&#125;class HumanEmployee implements Employee&#123; public function work(): void &#123; // ....working &#125; public function eat(): void &#123; // ...... eating in lunch break &#125;&#125;class RobotEmployee implements Employee&#123; public function work(): void &#123; //.... working much more &#125; public function eat(): void &#123; //.... robot can't eat, but it must implement this method &#125;&#125; 好: 不是每一个工人都是雇员，但是每一个雇员都是一个工人 1234567891011121314151617181920212223242526272829303132333435interface Workable&#123; public function work(): void;&#125;interface Feedable&#123; public function eat(): void;&#125;interface Employee extends Feedable, Workable&#123;&#125;class HumanEmployee implements Employee&#123; public function work(): void &#123; // ....working &#125; public function eat(): void &#123; //.... eating in lunch break &#125;&#125;// robot can only workclass RobotEmployee implements Workable&#123; public function work(): void &#123; // ....working &#125;&#125; ⬆ 返回顶部 依赖倒置原则Dependency Inversion Principle (DIP) 这条原则说明两个基本的要点： 高阶的模块不应该依赖低阶的模块，它们都应该依赖于抽象 抽象不应该依赖于实现，实现应该依赖于抽象 这条起初看起来有点晦涩难懂，但是如果你使用过 PHP 框架（例如 Symfony），你应该见过依赖注入（DI），它是对这个概念的实现。虽然它们不是完全相等的概念，依赖倒置原则使高阶模块与低阶模块的实现细节和创建分离。可以使用依赖注入（DI）这种方式来实现它。最大的好处是它使模块之间解耦。耦合会导致你难于重构，它是一种非常糟糕的的开发模式。 坏: 123456789101112131415161718192021222324252627282930class Employee&#123; public function work(): void &#123; // ....working &#125;&#125;class Robot extends Employee&#123; public function work(): void &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage(): void &#123; $this-&gt;employee-&gt;work(); &#125;&#125; 好: 1234567891011121314151617181920212223242526272829303132333435interface Employee&#123; public function work(): void;&#125;class Human implements Employee&#123; public function work(): void &#123; // ....working &#125;&#125;class Robot implements Employee&#123; public function work(): void &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage(): void &#123; $this-&gt;employee-&gt;work(); &#125;&#125; ⬆ 返回顶部 别写重复代码 (DRY)试着去遵循DRY 原则. 尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。 试想一下，如果你在经营一家餐厅并且你在记录你仓库的进销记录：所有的土豆，洋葱，大蒜，辣椒等。如果你有多个列表来管理进销记录，当你用其中一些土豆做菜时你需要更新所有的列表。如果你只有一个列表的话只有一个地方需要更新。 通常情况下你复制代码是应该有两个或者多个略微不同的逻辑，它们大多数都是一样的，但是由于它们的区别致使你必须有两个或者多个隔离的但大部分相同的方法，移除重复的代码意味着用一个function/module/class创建一个能处理差异的抽象。 用对抽象非常关键，这正是为什么你必须学习遵守在类章节写的SOLID原则，不合理的抽象比复制代码更糟糕，所以务必谨慎！说了这么多，如果你能设计一个合理的抽象，那就这么干！别写重复代码，否则你会发现任何时候当你想修改一个逻辑时你必须修改多个地方。 坏: 12345678910111213141516171819202122232425262728293031function showDeveloperList(array $developers): void&#123; foreach ($developers as $developer) &#123; $expectedSalary = $developer-&gt;calculateExpectedSalary(); $experience = $developer-&gt;getExperience(); $githubLink = $developer-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125;function showManagerList(array $managers): void&#123; foreach ($managers as $manager) &#123; $expectedSalary = $manager-&gt;calculateExpectedSalary(); $experience = $manager-&gt;getExperience(); $githubLink = $manager-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; 好: 123456789101112131415function showList(array $employees): void&#123; foreach ($employees as $employee) &#123; $expectedSalary = $employee-&gt;calculateExpectedSalary(); $experience = $employee-&gt;getExperience(); $githubLink = $employee-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; 极好: 最好让代码紧凑一点 12345678910function showList(array $employees): void&#123; foreach ($employees as $employee) &#123; render([ $employee-&gt;calculateExpectedSalary(), $employee-&gt;getExperience(), $employee-&gt;getGithubLink() ]); &#125;&#125; ⬆ 返回顶部","categories":[{"name":"php","slug":"php","permalink":"https://shiwenyuan.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://shiwenyuan.github.io/tags/php/"}]},{"title":"PHP-面向对象设计的三大特性","slug":"PHP-面向对象设计的三大特性","date":"2019-08-07T09:40:52.000Z","updated":"2019-08-08T10:08:12.172Z","comments":true,"path":"posts/cjzhzee5n0002sbs6voshj34b.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee5n0002sbs6voshj34b.html","excerpt":"","text":"面向对象的三大特性封装，继承，多态 什么是封装？把客观的事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类进行信息的隐藏。简单的说就是：封装使对象的设计者与对象的使用者分开，使用者只要知道对象可以做什么就可以了，不需要知道具体是怎么实现的。封装可以有助于提高类和系统的安全性。 什么是继承？继承指的是建立一个新的派生类，从一个或多个先前定义的类中继承数据和函数，可以重新定义或加进新数据和函数，从而建立了类的层次或等级。 什么是多态？多态性指的是： 同一操作作用与不同类的实例，将产生不同的执行结果，即不同类的对象收到相同的消息时，将得到不同的结果。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://shiwenyuan.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shiwenyuan.github.io/tags/设计模式/"}]},{"title":"PHP-面向对象设计的五个基准原则","slug":"PHP-面向对象设计的五个基准原则","date":"2019-08-07T09:34:58.000Z","updated":"2019-08-08T10:08:12.177Z","comments":true,"path":"posts/cjzhzee5t0005sbs6e3mq4ryy.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee5t0005sbs6e3mq4ryy.html","excerpt":"","text":"前言S.O.L.I.D 是 首个 5 个面向对象设计 (OOD) 准则的首字母缩写这些准则使得开发出易扩展、可维护的软件变得更容易。也使得代码更精简、易于重构。同样也是敏捷开发和自适应软件开发的一部分。 S.O.L.I.D S.O.L.I.D 意思是 S - 单一功能原则O - 开闭原则L - 里氏替换原则I - 接口隔离原则D - 依赖反转原则 单一职责原则一个类有且只能有一个因素使其改变，意思是一个类只应该有单一职责． 开闭原则对象和实体应该对扩展开放，但是对修改关闭． 里氏替换原则如果对每一个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 接口隔离原则使用方（client）不应该依赖强制实现不使用的接口，或不应该依赖不使用的方法。 依赖倒置原则实体必须依赖抽象而不是具体的实现．即高等级模块不应该依赖低等级模块，他们都应该依赖抽象．","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://shiwenyuan.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shiwenyuan.github.io/tags/设计模式/"}]},{"title":"腾讯面试","slug":"腾讯面试","date":"2019-08-07T09:29:10.000Z","updated":"2019-08-08T10:06:19.878Z","comments":true,"path":"posts/cjzhzee67000fsbs6d9n26yqp.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee67000fsbs6d9n26yqp.html","excerpt":"","text":"本文偶然间在laravel-china上看到过，还不错拿出来和大家分享下，原文请移步 https://learnku.com/articles/28896","categories":[{"name":"面试","slug":"面试","permalink":"https://shiwenyuan.github.io/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shiwenyuan.github.io/tags/面试/"}]},{"title":"PHP 面试踩过的坑","slug":"PHP-面试踩过的坑","date":"2019-08-07T09:26:34.000Z","updated":"2019-08-08T10:08:12.166Z","comments":true,"path":"posts/cjzhzee5u0006sbs68dqa3efg.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee5u0006sbs68dqa3efg.html","excerpt":"","text":"本文偶然间在laravel-china上看到过，还不错拿出来和大家分享下，原文请移步 https://learnku.com/articles/28758","categories":[{"name":"面试","slug":"面试","permalink":"https://shiwenyuan.github.io/categories/面试/"},{"name":"php","slug":"面试/php","permalink":"https://shiwenyuan.github.io/categories/面试/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://shiwenyuan.github.io/tags/php/"},{"name":"面试","slug":"面试","permalink":"https://shiwenyuan.github.io/tags/面试/"}]},{"title":"Redis “缓存穿透”、“缓存击穿”、“缓存雪崩”","slug":"Redis-“缓存穿透”、“缓存击穿”、“缓存雪崩”","date":"2019-08-07T09:16:18.000Z","updated":"2019-08-08T10:02:11.544Z","comments":true,"path":"posts/cjzhzee5y000asbs6jv0chold.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee5y000asbs6jv0chold.html","excerpt":"","text":"前几天去面试了，吃了点亏。面试官问我，你知道 “缓存穿透”、“缓存击穿”、“缓存雪崩” 吗？我当时确实不知道这些高大上的名词是什么意思，就是我没听过，不知道是啥意思，面试官说，你这方面好薄弱啊～～～面试结束之后我百度了一下，我去，看起来高大上的名字，其实是很常见的场景，相信很多人都会处理，缓存穿透 ： DB 承受了没有必要的查询流量，意思就是查到空值的时候没有做缓存处理，再次查询的时候继续读库了缓存击穿：热点 Key，大量并发读请求引起的小雪崩， 就是缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮缓存雪崩：缓存设置同一过期时间，引发的大量的读取数据库操作 分享一个讲解的链接：https://www.jianshu.com/p/fef1c22d63cb 专业术语还是得多了解一下，不然即使自己能解决的问题，别人用专业术语问的也不知道是个什么东西","categories":[{"name":"db","slug":"db","permalink":"https://shiwenyuan.github.io/categories/db/"},{"name":"redis","slug":"db/redis","permalink":"https://shiwenyuan.github.io/categories/db/redis/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shiwenyuan.github.io/tags/面试/"},{"name":"redis","slug":"redis","permalink":"https://shiwenyuan.github.io/tags/redis/"},{"name":"db","slug":"db","permalink":"https://shiwenyuan.github.io/tags/db/"}]},{"title":"单例模式（Singleton）","slug":"单例模式（Singleton）","date":"2019-08-07T08:47:39.000Z","updated":"2019-08-08T10:06:19.881Z","comments":true,"path":"posts/cjzhzee5w0007sbs6jl5oiftv.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee5w0007sbs6jl5oiftv.html","excerpt":"","text":"目的在应用程序调用的时候，只能获得一个对象实例。 例子数据库连接 UML 类图 特点 三私一公 私有静态成员变量私有构造函数私有克隆函数公共静态方法 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546cat Singleton.php&lt;?phpnamespace DesignPatterns\\Creational\\Singleton;final class Singleton&#123; /** * @var Singleton */ private static $instance; /** * 通过懒加载获得实例（在第一次使用的时候创建） */ public static function getInstance(): Singleton &#123; if (null === static::$instance) &#123; static::$instance = new static(); &#125; return static::$instance; &#125; /** * 不允许从外部调用以防止创建多个实例 * 要使用单例，必须通过 Singleton::getInstance() 方法获取实例 */ private function __construct() &#123; &#125; /** * 防止实例被克隆（这会创建实例的副本） */ private function __clone() &#123; &#125; /** * 防止反序列化（这将创建它的副本） */ private function __wakeup() &#123; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://shiwenyuan.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shiwenyuan.github.io/tags/设计模式/"}]},{"title":"MySQL 索引原理以及优化","slug":"MySQL-索引原理以及优化","date":"2019-08-07T08:22:24.000Z","updated":"2019-08-08T10:08:12.175Z","comments":true,"path":"posts/cjzhzee9p0021sbs6l8lx3wnv.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee9p0021sbs6l8lx3wnv.html","excerpt":"","text":"前言 本文是美团一位大佬写的，还不错拿出来和大家分享下，原文请移步 https://tech.meituan.com/2014/06/30/mysql-index.html 背景 MySQL 凭借着出色的性能、低廉的成本、丰富的资源，已经成为绝大多数互联网公司的首选关系型数据库。虽然性能出色，但所谓 “好马配好鞍”，如何能够更好的使用它，已经成为开发工程师的必修课，我们经常会从职位描述上看到诸如 “精通 MySQL”、“SQL 语句优化”、“了解数据库原理” 等要求。我们知道一般的应用系统，读写比例在 10:1 左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。 本人从 13 年 7 月份起，一直在美团核心业务系统部做慢查询的优化工作，共计十余个系统，累计解决和积累了上百个慢查询案例。随着业务的复杂性提升，遇到的问题千奇百怪，五花八门，匪夷所思。本文旨在以开发工程师的角度来解释数据库索引的原理和如何优化慢查询。 一个慢查询引发的思考12345678910select count(*) from task where status=2 and operator_id=20839 and operate_time&gt;1371169729 and operate_time&lt;1371174603 and type=2; 系统使用者反应有一个功能越来越慢，于是工程师找到了上面的SQL。 并且兴致冲冲的找到了我，“这个SQL需要优化，给我把每个字段都加上索引”。 我很惊讶，问道：“为什么需要每个字段都加上索引？” “把查询的字段都加上索引会更快”，工程师信心满满。 “这种情况完全可以建一个联合索引，因为是最左前缀匹配，所以operate_time需要放到最后，而且还需要把其他相关的查询都拿来，需要做一个综合评估。” “联合索引？最左前缀匹配？综合评估？”工程师不禁陷入了沉思。 多数情况下，我们知道索引能够提高查询效率，但应该如何建立索引？索引的顺序如何？许多人却只知道大概。其实理解这些概念并不难，而且索引的原理远没有想象的那么复杂。 MySQL索引原理索引目的索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？ 索引原理除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。 数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。 磁盘IO与预读前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考： 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。 索引的数据结构前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。 详解b+树 如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。 b+树的查找过程如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。 b+树性质1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。 2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。 慢查询优化关于MySQL索引原理是比较枯燥的东西，大家只需要有一个感性的认识，并不需要理解得非常透彻和深入。我们回头来看看一开始我们说的慢查询，了解完索引原理之后，大家是不是有什么想法呢？先总结一下索引的几大基本原则： 建索引的几大原则1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。 3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。 4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。 5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 回到开始的慢查询根据最左匹配原则，最开始的sql语句的索引应该是status、operator_id、type、operate_time的联合索引；其中status、operator_id、type的顺序可以颠倒，所以我才会说，把这个表的所有相关查询都找到，会综合分析；比如还有如下查询： 1select * from task where status = 0 and type = 12 limit 10; 1select count(*) from task where status = 0 ; 那么索引建立成(status,type,operator_id,operate_time)就是非常正确的，因为可以覆盖到所有情况。这个就是利用了索引的最左匹配的原则 查询优化神器 - explain命令关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网explain-output，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。 慢查询优化基本步骤0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE 1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高 2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询） 3.order by limit 形式的sql语句让排序的表优先查 4.了解业务方使用场景 5.加索引时参照建索引的几大原则 6.观察结果，不符合预期继续从0分析 几个慢查询案例下面几个例子详细解释了如何分析和优化慢查询。 复杂语句写法很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句： 12345678910111213141516171819202122232425262728select distinct cert.emp_id from cm_log cl inner join ( select emp.id as emp_id, emp_cert.id as cert_id from employee emp left join emp_certificate emp_cert on emp.id = emp_cert.emp_id where emp.is_deleted=0 ) cert on ( cl.ref_table='Employee' and cl.ref_oid= cert.emp_id ) or ( cl.ref_table='EmpCertificate' and cl.ref_oid= cert.cert_id ) where cl.last_upd_date &gt;='2013-11-07 15:03:00' and cl.last_upd_date&lt;='2013-11-08 16:00:00'; 0.先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢 153 rows in set (1.87 sec) 1.explain 12345678+----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+| 1 | PRIMARY | cl | range | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8 | NULL | 379 | Using where; Using temporary || 1 | PRIMARY | &lt;derived2&gt; | ALL | NULL | NULL | NULL | NULL | 63727 | Using where; Using join buffer || 2 | DERIVED | emp | ALL | NULL | NULL | NULL | NULL | 13317 | Using where || 2 | DERIVED | emp_cert | ref | emp_certificate_empid | emp_certificate_empid | 4 | meituanorg.emp.id | 1 | Using index |+----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+ 简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。 如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。 优化过的语句如下： 12345678910111213141516171819202122232425262728select emp.id from cm_log cl inner join employee emp on cl.ref_table = 'Employee' and cl.ref_oid = emp.id where cl.last_upd_date &gt;='2013-11-07 15:03:00' and cl.last_upd_date&lt;='2013-11-08 16:00:00' and emp.is_deleted = 0 unionselect emp.id from cm_log cl inner join emp_certificate ec on cl.ref_table = 'EmpCertificate' and cl.ref_oid = ec.id inner join employee emp on emp.id = ec.emp_id where cl.last_upd_date &gt;='2013-11-07 15:03:00' and cl.last_upd_date&lt;='2013-11-08 16:00:00' and emp.is_deleted = 0 4.不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致 5.现有索引可以满足，不需要建索引 6.用改造后的语句实验一下，只需要10ms 降低了近200倍！ 1234567891011+----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+| 1 | PRIMARY | cl | range | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8 | NULL | 379 | Using where || 1 | PRIMARY | emp | eq_ref | PRIMARY | PRIMARY | 4 | meituanorg.cl.ref_oid | 1 | Using where || 2 | UNION | cl | range | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8 | NULL | 379 | Using where || 2 | UNION | ec | eq_ref | PRIMARY,emp_certificate_empid | PRIMARY | 4 | meituanorg.cl.ref_oid | 1 | || 2 | UNION | emp | eq_ref | PRIMARY | PRIMARY | 4 | meituanorg.ec.emp_id | 1 | Using where || NULL | UNION RESULT | &lt;union1,2&gt; | ALL | NULL | NULL | NULL | NULL | NULL | |+----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+53 rows in set (0.01 sec) 明确应用场景举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的。 1234567891011select * from stage_poi sp where sp.accurate_result=1 and ( sp.sync_status=0 or sp.sync_status=2 or sp.sync_status=4 ); 0.先看看运行多长时间,951条数据6.22秒，真的很慢。 1951 rows in set (6.22 sec) 1.先explain，rows达到了361万，type = ALL表明是全表扫描。 12345+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+| 1 | SIMPLE | sp | ALL | NULL | NULL | NULL | NULL | 3613155 | Using where |+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+ 2.所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条。 3.让explain的rows 尽量逼近951。 看一下accurate_result = 1的记录数： 12345678select count(*),accurate_result from stage_poi group by accurate_result;+----------+-----------------+| count(*) | accurate_result |+----------+-----------------+| 1023 | -1 || 2114655 | 0 || 972815 | 1 |+----------+-----------------+ 我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据。 再看一下sync_status字段的情况： 1234567select count(*),sync_status from stage_poi group by sync_status;+----------+-------------+| count(*) | sync_status |+----------+-------------+| 3080 | 0 || 3085413 | 3 |+----------+-------------+ 同样的区分度也很低，根据理论，也不适合建立索引。 问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁定记录也是百万级别的。 4.找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据。 5.根据建立索引规则，使用如下语句建立索引 1alter table stage_poi add index idx_acc_status(accurate_result,sync_status); 6.观察预期结果,发现只需要200ms，快了30多倍。 1952 rows in set (0.20 sec) 我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。 无法优化的语句12345678910111213141516171819202122232425262728293031323334353637select c.id, c.name, c.position, c.sex, c.phone, c.office_phone, c.feature_info, c.birthday, c.creator_id, c.is_keyperson, c.giveup_reason, c.status, c.data_source, from_unixtime(c.created_time) as created_time, from_unixtime(c.last_modified) as last_modified, c.last_modified_user_id from contact c inner join contact_branch cb on c.id = cb.contact_id inner join branch_user bu on cb.branch_id = bu.branch_id and bu.status in ( 1, 2) inner join org_emp_info oei on oei.data_id = bu.user_id and oei.node_left &gt;= 2875 and oei.node_right &lt;= 10802 and oei.org_category = - 1 order by c.created_time desc limit 0 , 10; 还是几个步骤。 0.先看语句运行多长时间，10条记录用了13秒，已经不可忍受。 110 rows in set (13.06 sec) 1.explain 12345678+----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+| 1 | SIMPLE | oei | ref | idx_category_left_right,idx_data_id | idx_category_left_right | 5 | const | 8849 | Using where; Using temporary; Using filesort || 1 | SIMPLE | bu | ref | PRIMARY,idx_userid_status | idx_userid_status | 4 | meituancrm.oei.data_id | 76 | Using where; Using index || 1 | SIMPLE | cb | ref | idx_branch_id,idx_contact_branch_id | idx_branch_id | 4 | meituancrm.bu.branch_id | 1 | || 1 | SIMPLE | c | eq_ref | PRIMARY | PRIMARY | 108 | meituancrm.cb.contact_id | 1 | |+----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+ 从执行计划上看，mysql先查org_emp_info表扫描8849记录，再用索引idx_userid_status关联branch_user表，再用索引idx_branch_id关联contact_branch表，最后主键关联contact表。 rows返回的都非常少，看不到有什么异常情况。我们在看一下语句，发现后面有order by + limit组合，会不会是排序量太大搞的？于是我们简化SQL，去掉后面的order by 和 limit，看看到底用了多少记录来排序。 12345678910111213141516171819202122232425select count(*)from contact c inner join contact_branch cb on c.id = cb.contact_id inner join branch_user bu on cb.branch_id = bu.branch_id and bu.status in ( 1, 2) inner join org_emp_info oei on oei.data_id = bu.user_id and oei.node_left &gt;= 2875 and oei.node_right &lt;= 10802 and oei.org_category = - 1 +----------+| count(*) |+----------+| 778878 |+----------+1 row in set (5.19 sec) 发现排序之前居然锁定了778878条记录，如果针对70万的结果集排序，将是灾难性的，怪不得这么慢，那我们能不能换个思路，先根据contact的created_time排序，再来join会不会比较快呢？ 于是改造成下面的语句，也可以用straight_join来优化： 12345678910111213141516171819202122232425262728293031323334353637383940414243select c.id, c.name, c.position, c.sex, c.phone, c.office_phone, c.feature_info, c.birthday, c.creator_id, c.is_keyperson, c.giveup_reason, c.status, c.data_source, from_unixtime(c.created_time) as created_time, from_unixtime(c.last_modified) as last_modified, c.last_modified_user_id from contact c where exists ( select 1 from contact_branch cb inner join branch_user bu on cb.branch_id = bu.branch_id and bu.status in ( 1, 2) inner join org_emp_info oei on oei.data_id = bu.user_id and oei.node_left &gt;= 2875 and oei.node_right &lt;= 10802 and oei.org_category = - 1 where c.id = cb.contact_id ) order by c.created_time desc limit 0 , 10; 验证一下效果 预计在1ms内，提升了13000多倍！ 110 rows in set (0.00 sec) 本以为至此大工告成，但我们在前面的分析中漏了一个细节，先排序再join和先join再排序理论上开销是一样的，为何提升这么多是因为有一个limit！大致执行过程是：mysql先按索引排序得到前10条记录，然后再去join过滤，当发现不够10条的时候，再次去10条，再次join，这显然在内层join过滤的数据非常多的时候，将是灾难的，极端情况，内层一条数据都找不到，mysql还傻乎乎的每次取10条，几乎遍历了这个数据表！ 用不同参数的SQL试验下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344select sql_no_cache c.id, c.name, c.position, c.sex, c.phone, c.office_phone, c.feature_info, c.birthday, c.creator_id, c.is_keyperson, c.giveup_reason, c.status, c.data_source, from_unixtime(c.created_time) as created_time, from_unixtime(c.last_modified) as last_modified, c.last_modified_user_id from contact c where exists ( select 1 from contact_branch cb inner join branch_user bu on cb.branch_id = bu.branch_id and bu.status in ( 1, 2) inner join org_emp_info oei on oei.data_id = bu.user_id and oei.node_left &gt;= 2875 and oei.node_right &lt;= 2875 and oei.org_category = - 1 where c.id = cb.contact_id ) order by c.created_time desc limit 0 , 10;Empty set (2 min 18.99 sec) 2 min 18.99 sec！比之前的情况还糟糕很多。由于mysql的nested loop机制，遇到这种情况，基本是无法优化的。这条语句最终也只能交给应用系统去优化自己的逻辑了。 通过这个例子我们可以看到，并不是所有语句都能优化，而往往我们优化时，由于SQL用例回归时落掉一些极端情况，会造成比原来还严重的后果。所以，第一：不要指望所有语句都能通过SQL优化，第二：不要过于自信，只针对具体case来优化，而忽略了更复杂的情况。 慢查询的案例就分析到这儿，以上只是一些比较典型的案例。我们在优化过程中遇到过超过1000行，涉及到16个表join的“垃圾SQL”，也遇到过线上线下数据库差异导致应用直接被慢查询拖死，也遇到过varchar等值比较没有写单引号，还遇到过笛卡尔积查询直接把从库搞死。再多的案例其实也只是一些经验的积累，如果我们熟悉查询优化器、索引的内部原理，那么分析这些案例就变得特别简单了。 写在后面的话本文以一个慢查询案例引入了MySQL索引原理、优化慢查询的一些方法论;并针对遇到的典型案例做了详细的分析。其实做了这么长时间的语句优化后才发现，任何数据库层面的优化都抵不上应用系统的优化，同样是MySQL，可以用来支撑Google/FaceBook/Taobao应用，但可能连你的个人网站都撑不住。套用最近比较流行的话：“查询容易，优化不易，且写且珍惜！” 参考文献：1.《高性能MySQL》 2.《数据结构与算法分析》","categories":[{"name":"db","slug":"db","permalink":"https://shiwenyuan.github.io/categories/db/"},{"name":"mysql","slug":"db/mysql","permalink":"https://shiwenyuan.github.io/categories/db/mysql/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shiwenyuan.github.io/tags/面试/"},{"name":"db","slug":"db","permalink":"https://shiwenyuan.github.io/tags/db/"},{"name":"mysql","slug":"mysql","permalink":"https://shiwenyuan.github.io/tags/mysql/"},{"name":"优化","slug":"优化","permalink":"https://shiwenyuan.github.io/tags/优化/"}]},{"title":"科学上网","slug":"mac科学上网","date":"2019-08-07T02:25:13.000Z","updated":"2019-08-12T10:46:04.696Z","comments":true,"path":"posts/cjzhzee69000hsbs6vd9r17lq.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee69000hsbs6vd9r17lq.html","excerpt":"","text":"https://glados.network/login邮箱注册、初始免费用30t，亲测有效 这个网站是我偶然间听别人说的，就抱着试一试的态度去注册了一下，结果非常令人开心，要比我之前用到那个网站快很多，本着好东西就要分享出来的态度分享给大家 当前的网站还在内测阶段所以注册时候必须要一个邀请码:DEC8I-ANGH8-XBZ34-NL33I","categories":[{"name":"系统工具","slug":"系统工具","permalink":"https://shiwenyuan.github.io/categories/系统工具/"}],"tags":[{"name":"系统工具","slug":"系统工具","permalink":"https://shiwenyuan.github.io/tags/系统工具/"}]},{"title":"nginx配置https","slug":"nginx配置https","date":"2019-08-06T03:38:32.000Z","updated":"2019-08-08T10:08:12.180Z","comments":true,"path":"posts/cjzhzee82001osbs6z56zzv9y.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee82001osbs6z56zzv9y.html","excerpt":"","text":"网站https网站https化已是大势所趋，个人blog也都可以把https玩儿起来！ Let’s Encrypt123这个免费、自动化、开放的证书签发服务。它由 ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let&apos;s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。申请 Let&apos;s Encrypt 证书不但免费，还非常简单，虽然每次只有 90 天的有效期，但可以通过脚本定期更新，配好之后一劳永逸。经过一段时间的观望，我也正式启用 Let&apos;s Encrypt 证书了，本文记录本站申请过程和遇到的问题。我没有使用 Let&apos;s Encrypt 官网提供的工具来申请证书，而是用了 [acme.sh](http://https://github.com/Neilpang/acme.sh &quot;acme.sh&quot;) 这个更为小巧的开源工具。以下内容基本按照 acme的说明文档写的，省略了一些我不需要的步骤。 配置验证服务1传统 CA 的验证方式一般是往 admin@youremail.com 发验证邮件，而 Let&apos;s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。 配置前提11. nginx安装了https模块 通过web访问check域名权限步骤1（建立目录或者nginx访问规则）CA认证12345location ^~ /.well-known/acme-challenge/ &#123; # 注：这里的$challenges_dir请替换成你自己的真实目录，如：/home/work/www/challenges/ alias $challenges_dir; try_files $uri =404;&#125; or 12在项目根目录添加.well-known/acme-challengeLet&apos;s Encrypt 用来校验网站权限 步骤二 生成证书1./acme.sh --issue -d diancan.xiaochengxu.phpblog.com.cn --webroot /home/www/xiaochengxu/diancan 步骤三 cp证书到指定位置1234acme.sh --installcert -d www.your-app.com \\ --keypath /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn.key \\ --fullchainpath /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn.key.pem \\ --reloadcmd &quot; /usr/local/nginx/sbin/nginx -s reload&quot; 步骤四 配置nginx1234567891011121314151617181920212223242526server &#123; listen 80; server_name diancan.xiaochengxu.phpblog.com.cn; location / &#123; rewrite ^/(.*)$ https://diancan.xiaochengxu.phpblog.com.cn; &#125;&#125;server &#123; listen 443 ssl; server_name diancan.xiaochengxu.phpblog.com.cn; include /usr/local/nginx/ssl/ssl_params; ssl_certificate /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn/diancan.xiaochengxu.phpblog.com.cn.cer; ssl_certificate_key /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn/diancan.xiaochengxu.phpblog.com.cn.key; root /home/www/diancan/xiaochengxu; # 该项要修改为你准备存放相关网页的路径 include /usr/local/nginx/ssl/ssl_headers; location / &#123; try_files $uri $uri/ /index.php?$query_string; index index.php index.html index.htm; &#125; location ~ \\.php$ &#123; include /usr/local/nginx/conf/fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; &#125; &#125; 123456789101112# out /usr/local/nginx/ssl/ssl_headersadd_header Strict-Transport-Security &quot;max-age=15768000; includeSubDomains; preload&quot; always;# out /usr/local/nginx/ssl/ssl_paramsssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_dhparam /usr/local/nginx/ssl/dhparam.pem; # See https://weakdh.org/sysadmin.html for more detailsssl_session_cache shared:SSL:1m;ssl_session_timeout 5m;ssl_prefer_server_ciphers on;ssl_ciphers &quot;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&quot;;dhparam.pem这个文件是我之前就生成好的，生成命令openssl dhparam -out /usr/local/nginx/ssl/dhparam.pem 2048 步骤五 重启nginx查看证书自动更新申请下来的证书有效期只有90天 123在crontab 中添加一条命令0 0 * * * /home/work/opbin/ssl/acme.sh-master/acme.sh --cron --home /home/work/opbin/ssl/acme.sh-master/acme.sh此处就是每天凌晨检查证书 证书会在60天的时候更新 因为acme会记住之前执行的installcert，所以更新完证书之后他会自动重启一下nginx 如果之前运行installcert的时候没有输入reloadcmd,则需要更新之后自己手动重启(这样就没有自动更新的意义了) 通过dns配置check权限手动配置步骤1123456789101112131415161718192021222324252627282930313233343536[work@iZ25ndyf9bxZ acme.sh-master]$ !1019./acme.sh --issue --dns -d *.test.com -d test.com --yes-I-know-dns-manual-mode-enough-go-ahead-please[Tue Sep 11 21:24:56 CST 2018] Creating domain key[Tue Sep 11 21:24:56 CST 2018] The domain key is here: /home/work/.acme.sh/*.test.com/*.test.com.key[Tue Sep 11 21:24:56 CST 2018] Multi domain=&apos;DNS:*.test.com,test.com&apos;[Tue Sep 11 21:24:56 CST 2018] Getting domain auth token for each domain[Tue Sep 11 21:24:59 CST 2018] Getting webroot for domain=&apos;*.test.com&apos;[Tue Sep 11 21:25:00 CST 2018] Getting webroot for domain=&apos;test.com&apos;[Tue Sep 11 21:25:00 CST 2018] Add the following TXT record:[Tue Sep 11 21:25:00 CST 2018] Domain: &apos;_acme-challenge.test.com&apos;[Tue Sep 11 21:25:00 CST 2018] TXT value: &apos;Oe0iBXj3QvUErZOpROldRLx5jpyXbazsX36lkI46C_Y&apos;[Tue Sep 11 21:25:00 CST 2018] Please be aware that you prepend _acme-challenge. before your domain[Tue Sep 11 21:25:00 CST 2018] so the resulting subdomain will be: _acme-challenge.test.com[Tue Sep 11 21:25:00 CST 2018] Add the following TXT record:[Tue Sep 11 21:25:00 CST 2018] Domain: &apos;_acme-challenge.test.com&apos;[Tue Sep 11 21:25:00 CST 2018] TXT value: &apos;qVFtVzCnBsj1omQcdU1m8180rUBO8V5AHDczFUHqsMY&apos;[Tue Sep 11 21:25:00 CST 2018] Please be aware that you prepend _acme-challenge. before your domain[Tue Sep 11 21:25:00 CST 2018] so the resulting subdomain will be: _acme-challenge.test.com[Tue Sep 11 21:25:00 CST 2018] Please add the TXT records to the domains, and re-run with --renew.[Tue Sep 11 21:25:00 CST 2018] Please check log file for more details: /home/work/.acme.sh/acme.sh.log[work@iZ25ndyf9bxZ acme.sh-master]$ ./acme.sh --renew --dns -d *.test.com -d test.com --yes-I-know-dns-manual-mode-enough-go-ahead-please[Tue Sep 11 21:31:18 CST 2018] Renew: &apos;*.test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Multi domain=&apos;DNS:*.test.com,test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Getting domain auth token for each domain[Tue Sep 11 21:31:19 CST 2018] Verifying:*.test.com[Tue Sep 11 21:31:24 CST 2018] Success[Tue Sep 11 21:31:24 CST 2018] Verifying:test.com[Tue Sep 11 21:31:27 CST 2018] Success[Tue Sep 11 21:31:27 CST 2018] Verify finished, start to sign.[Tue Sep 11 21:31:30 CST 2018] Cert success.这个上面说的是需要在dns中添加Domain: &apos;_acme-challenge.test.com&apos;TXT value: &apos;Oe0iBXj3QvUErZOpROldRLx5jpyXbazsX36lkI46C_Y&apos;与 Domain: &apos;_acme-challenge.test.com&apos;TXT value: &apos;qVFtVzCnBsj1omQcdU1m8180rUBO8V5AHDczFUHqsMY&apos; 生效后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[work@iZ25ndyf9bxZ acme.sh-master]$ ./acme.sh --renew --dns -d *.test.com -d test.com --yes-I-know-dns-manual-mode-enough-go-ahead-please[Tue Sep 11 21:31:18 CST 2018] Renew: &apos;*.test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Multi domain=&apos;DNS:*.test.com,DNS:test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Getting domain auth token for each domain[Tue Sep 11 21:31:19 CST 2018] Verifying:*.test.com[Tue Sep 11 21:31:24 CST 2018] Success[Tue Sep 11 21:31:24 CST 2018] Verifying:test.com[Tue Sep 11 21:31:27 CST 2018] Success[Tue Sep 11 21:31:27 CST 2018] Verify finished, start to sign.[Tue Sep 11 21:31:30 CST 2018] Cert success.-----BEGIN CERTIFICATE-----MIIGGDCCBQCgAwIBAgISA/ZIZ/p9WiVXaWSVytreKZWhMA0GCSqGSIb3DQEBCwUAMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQDExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xODA5MTExMjMxMjNaFw0xODEyMTAxMjMxMjNaMBoxGDAWBgNVBAMMDyoueG1hbmxlZ2FsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANnH033ObKrmxX9eLIKqt3kKxcIrcfabqnLJ0nGnjLRaOXco7B3q865OHx4PTKNT89RSAzfJQ5ZSXBY8QqbZAKv8kAzPA7yE0wliJ3rYCesVfAR1CgnOc+jQkTjlZp0q138/GDthgplvaziJUTaGL31Dj338oFU3xmyMxp2JmzUUjD4KkoHPZql5xkQ3pLzxRInWGMfal7f4oHaZQJr1Xwyu5BR/m9G1+PBlmqGsTka75n5i8uchjIFPAuH48c9fEJXLB0TSUfvAdi9HDpVxXsglmiw4eL5JF5ORYIKajAXObt/vl2uNbUHYV5Mr74jr7U/YqAA48X/x9jeHaVNSS/sCAwEAAaOCAyYwggMiMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUhLPM1+fVbGsgfc1CFAsRyu96DUMwHwYDVR0jBBgwFoAUqEpqYwR93brm0Tm3pkVl7/Oo7KEwbwYIKwYBBQUHAQEEYzBhMC4GCCsGAQUFBzABhiJodHRwOi8vb2NzcC5pbnQteDMubGV0c2VuY3J5cHQub3JnMC8GCCsGAQUFBzAChiNodHRwOi8vY2VydC5pbnQteDMubGV0c2VuY3J5cHQub3JnLzApBgNVHREEIjAggg8qLnhtYW5sZWdhbC5jb22CDXhtYW5sZWdhbC5jb20wgf4GA1UdIASB9jCB8zAIBgZngQwBAgEwgeYGCysGAQQBgt8TAQEBMIHWMCYGCCsGAQUFBwIBFhpodHRwOi8vY3BzLmxldHNlbmNyeXB0Lm9yZzCBqwYIKwYBBQUHAgIwgZ4MgZtUaGlzIENlcnRpZmljYXRlIG1heSBvbmx5IGJlIHJlbGllZCB1cG9uIGJ5IFJlbHlpbmcgUGFydGllcyBhbmQgb25seSBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIENlcnRpZmljYXRlIFBvbGljeSBmb3VuZCBhdCBodHRwczovL2xldHNlbmNyeXB0Lm9yZy9yZXBvc2l0b3J5LzCCAQQGCisGAQQB1nkCBAIEgfUEgfIA8AB2AMEWSuCnctLUOS3ICsEHcNTwxJvemRpIQMH6B1Fk9jNgAAABZcjUVQgAAAQDAEcwRQIhALEwfEJJ6OS6IiWZNXZEO/ymIAgZGpD812KCt484URUHAiAW6FCC+6rYa1AFUdT/vFcC3nc4MC9IGHLPOKyiyC8pEAB2AKRQEmkFWhVUXmIRqze8ED9irlV2pF5LFxRFPhsiEGolAAABZcjUVQoAAAQDAEcwRQIgETcbXZ/E5QEB/oRR3xr4B3dZELF4TfnTJJgH7J8YF9gCIQCKq4jXNwJjCAJDz0K81MaoAZ23CImUYJIHCVJTitzphzANBgkqhkiG9w0BAQsFAAOCAQEAPWWEp4v4cvU3c+fgt2a0mQXI5q0gmYQAYaxyXubs3HfxFsFXzroAPH6wvLk/Cw1EciBInnXtvQ+DDfi4FsyhWn598czJ/YEIGiV7ZCi1Ah8NVniST+R3nVIBqhSDCGOpmHdvtfCRCoZErAVFvv0ABsQUSQHkEYmiPwEddhU5srOENzcV4qel/9/bzK3hGlPWB8jLvWQ8uHtSHibGAJsnEG0rMYkFs6pqnzM2EFdRNfm3axDKD8Gai7V5Ezu31iwvgZXjLmhl6xtH3CzkqmPaDarxJtnZLet8SLaEY0inmbhvupOGLUuO+EnAXlxk40z8V1/GtWuyYMz38OwCWcB5fA==-----END CERTIFICATE-----[Tue Sep 11 21:31:30 CST 2018] Your cert is in /home/work/.acme.sh/*.test.com/*.test.com.cer [Tue Sep 11 21:31:30 CST 2018] Your cert key is in /home/work/.acme.sh/*.test.com/*.test.com.key [Tue Sep 11 21:31:30 CST 2018] The intermediate CA cert is in /home/work/.acme.sh/*.test.com/ca.cer [Tue Sep 11 21:31:30 CST 2018] And the full chain certs is there: /home/work/.acme.sh/*.test.com/fullchain.cer [Tue Sep 11 21:31:30 CST 2018] It seems that you are using dns manual mode. please take care: The dns manual mode can not renew automatically, you must issue it again manually. You&apos;d better use the other modes instead.[Tue Sep 11 21:31:30 CST 2018] Call hook error. 生成成功后配置 123456789[work@iZ25ndyf9bxZ acme.sh-master]$ ./acme.sh --installcert -d *.xmanlegal.com \\&gt; --key-file /mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key \\&gt; --fullchain-file /mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key.cer \\&gt; --reloadcmd &quot;echo &quot;Asdf1234&quot; sudo -S /mnt/usr/sbin/nginx -s reload&quot;[Tue Sep 11 21:36:31 CST 2018] Installing key to:/mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key[Tue Sep 11 21:36:31 CST 2018] Installing full chain to:/mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key.cer[Tue Sep 11 21:36:31 CST 2018] Run reload cmd: echo Asdf1234 sudo -S /mnt/usr/sbin/nginx -s reloadAsdf1234 sudo -S /mnt/usr/sbin/nginx -s reload[Tue Sep 11 21:36:31 CST 2018] Reload success 末文证书级别测试相关技术博客","categories":[{"name":"nginx","slug":"nginx","permalink":"https://shiwenyuan.github.io/categories/nginx/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://shiwenyuan.github.io/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://shiwenyuan.github.io/tags/nginx/"},{"name":"https","slug":"https","permalink":"https://shiwenyuan.github.io/tags/https/"}]},{"title":"开发自己的composer包","slug":"开发自己的composer包","date":"2019-08-06T03:38:17.000Z","updated":"2019-08-08T10:06:19.883Z","comments":true,"path":"posts/cjzhzee60000bsbs6ae3q7w73.html","link":"","permalink":"https://shiwenyuan.github.io/posts/cjzhzee60000bsbs6ae3q7w73.html","excerpt":"","text":"composer简介1Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。 准备工作 1.一个github账号 2.一个packagist账号 3.一台安装composer的开发机 packagist注册链接 github注册链接 composer注册链接 — # 发布流程 1.首先在github上创建一个项目2.把项目克隆到本地3.进入项目根目录初始化项目123456789101112131415161718192021222324252627282930313233343536373839➜ xdpframework git:(master) composer init Welcome to the Composer config generator This command will guide you through creating your composer.json config.Package name (&lt;vendor&gt;/&lt;name&gt;) [shiwenyuan/xdpframework]: Description []: a xdp frameworkAuthor [北行10000 &lt;13341007105@163.com&gt;, n to skip]: Minimum Stability []: devPackage Type (e.g. library, project, metapackage, composer-plugin) []: License []: MITDefine your dependencies.Would you like to define your dependencies (require) interactively [yes]? Search for a package: Would you like to define your dev dependencies (require-dev) interactively [yes]? Search for a package: &#123; &quot;name&quot;: &quot;shiwenyuan/xdpframework&quot;, &quot;description&quot;: &quot;a xdp framework&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;北行10000&quot;, &quot;email&quot;: &quot;13341007105@163.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123;&#125;&#125;Do you confirm generation [yes]? Would you like the vendor directory added to your .gitignore [yes]? yes 此时目录下回程车一个composer.json文件，文件内容形如 12345678910111213&#123; &quot;name&quot;: &quot;shiwenyuan/xdpframework&quot;, &quot;description&quot;: &quot;a xdp framework&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;北行10000&quot;, &quot;email&quot;: &quot;13341007105@163.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123;&#125;&#125; 4.编写自己的composer包4.1 此处我创建了一个src目录并实现了SayHello类123456➜ xdpframework git:(master) ✗ tree.├── README.md├── composer.json└── src └── SayHello.php 4.2 修改composer.json123456789101112131415161718&#123; &quot;name&quot;: &quot;shiwenyuan/xdpframework&quot;, &quot;description&quot;: &quot;a xdp framework&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;北行10000&quot;, &quot;email&quot;: &quot;13341007105@163.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123;&#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;XdpFrameWork\\\\&quot;: &quot;src/&quot; &#125; &#125;&#125; 4.3 自动加载src目录123456789101112131415161718192021222324在4.2添加了src的加载运行composer install实现自动加载➜ xdpframework git:(master) ✗ composer installLoading composer repositories with package informationUpdating dependencies (including require-dev)Nothing to install or updateGenerating autoload files此时目录中会生成一个vendor 它实现了加载方法➜ xdpframework git:(master) ✗ tree.├── README.md├── composer.json├── src│ └── SayHello.php└── vendor ├── autoload.php └── composer ├── ClassLoader.php ├── LICENSE ├── autoload_classmap.php ├── autoload_namespaces.php ├── autoload_psr4.php ├── autoload_real.php ├── autoload_static.php └── installed.json 4.4 测试结果1234567891011121314创建test.php&lt;?php/** * Created by PhpStorm. * User: shiwenyuan * Date: 2018/8/2 13341007105@163.com * Time: 下午8:56 */require_once __DIR__.&quot;/vendor/autoload.php&quot;;use XdpFrameWork\\SayHello;SayHello::world();命令行中运行➜ xdpframework git:(master) ✗ php test.phphello world 4.5 忽略vendor、composer.json文件12修改.gitignore增加下面两行/vendor/ 4.6提交代码到 github 5. Packagist配置5.1 github关联到Packagist1234561.首先要在Packagist上登录2.点击顶部导航条中的Summit按钮3.在输入框中输入github上的仓库地址，如：https://github.com/shiwenyuan/xdpfarmwork4.然后点击Check按钮5.Packagist会去检测此仓库地址的代码是否符合Composer的Package包的要求6.检测正常的话，会出现Submit按钮，再点击一下Submit按钮，我们的包就提交到Packagist上了 5.2 配置自动同步1231.从Packagist点击个人中心点击profile获取token然后复制2.到github项目首页上点击settings、点击webhooks、点击addwebhook3.把https://packagist.org/api/bitbucket?username=USERNAME&amp;apiToken=TOKEN 复制到Payload URL，在下方输入密码后保存 5.3 打tag测试 引用包1composer require shiwenyuan/xdpframework 注意事项123如果下载不下来到话就换一下镜像composer config -g repo.packagist composer https://packagist.laravel-china.org刚发布上去可能会下载不到，没有同步过来-- 可以等一会在试试看","categories":[{"name":"工具","slug":"工具","permalink":"https://shiwenyuan.github.io/categories/工具/"},{"name":"php","slug":"工具/php","permalink":"https://shiwenyuan.github.io/categories/工具/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://shiwenyuan.github.io/tags/php/"},{"name":"composer","slug":"composer","permalink":"https://shiwenyuan.github.io/tags/composer/"}]}]}