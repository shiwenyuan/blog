{"meta":{"title":"shiwenyuan'blog","subtitle":null,"description":"阿远的个人博客","author":"阿远","url":"http://shiwenyuan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-09-10T08:47:09.000Z","updated":"2019-09-19T01:51:58.966Z","comments":true,"path":"about/index.html","permalink":"http://shiwenyuan.github.io/about/index.html","excerpt":"","text":"email:stonewenyuan@gmail.com"},{"title":"分类","date":"2019-09-10T08:47:17.000Z","updated":"2019-09-19T01:52:30.435Z","comments":true,"path":"categories/index.html","permalink":"http://shiwenyuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-09-10T08:41:09.000Z","updated":"2019-09-19T01:52:57.801Z","comments":true,"path":"links/index.html","permalink":"http://shiwenyuan.github.io/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2019-09-10T08:41:38.000Z","updated":"2019-09-19T01:53:07.977Z","comments":true,"path":"repository/index.html","permalink":"http://shiwenyuan.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-10T08:41:20.000Z","updated":"2019-09-19T01:53:13.989Z","comments":true,"path":"tags/index.html","permalink":"http://shiwenyuan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Laravel-event简单使用","slug":"Laravel-event简单使用","date":"2019-09-26T04:19:55.000Z","updated":"2019-09-26T06:33:33.658Z","comments":true,"path":"post/ck107czq600028hfyi0a7ubrt.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czq600028hfyi0a7ubrt.html","excerpt":"","text":"event介绍Laravel的事件提供了一个简单的观察者实现，允许你在应用中订阅和监听各种发生的事件。事件类通常放在app/Events目录下，而这些事件类的监听器则放在 app/Listeners 目录下。如果在你的应用中你没有看到这些目录，不用担心，它们会在你使用Artisan控制台命令生成事件与监听器的时候自动创建。事件系统为应用各个方面的解耦提供了非常棒的方法，因为单个事件可以拥有多个互不依赖的监听器。举个例子，你可能希望每次订单发货时向用户推送一个 Slack 通知。你可以简单地发起一个可以被监听器接收并转化为Slack通知的OrderShipped事件，而不是将订单处理代码和Slack通知代码耦合在一起 生成一个事件类比如通过artisan命令生成一个UserLogin事件： 1php artisan make:event UserLogin 此时在app/Events中就会生成一个UserLogin.php文件（如果没有目录，届时将会自动创建）。文件内容如下: 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\Events;use Illuminate\\Broadcasting\\Channel;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Broadcasting\\PrivateChannel;use Illuminate\\Broadcasting\\PresenceChannel;use Illuminate\\Broadcasting\\InteractsWithSockets;use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;class UserLogin&#123; use InteractsWithSockets, SerializesModels; /** * Create a new event instance. * * @return void */ public function __construct() &#123; // &#125; /** * Get the channels the event should broadcast on. * * @return Channel|array */ public function broadcastOn() &#123; return new PrivateChannel('channel-name'); &#125;&#125; 定义监听器一个事件可以被一个或多个监听器监听，也就是观察者模式，我们可以定义多个监听器，当这个事件发生，执行一系列逻辑。 在app/Providers/EventServiceProvider.php的 $listen 中可以定义事件和监听器，如下： 123456protected $listen = [ 'App\\Events\\UserLogin' =&gt; [ 'App\\Lisenter\\DoSomething1', 'App\\Lisenter\\Dosomething2', ],]; 然后执行artisan命令，就可以自动在app/Lisenter目录生成监听器。 1php artisan event::generate 此时再去看app/Lisenter就会发现多了两个文件:app/Lisenter/DoSomething1.php 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Lisenter;use App\\Events\\UserLogin;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;class DoSomething1&#123; /** * Create the event listener. * * @return void */ public function __construct() &#123; // &#125; /** * Handle the event. * * @param UserLogin $event * @return void */ public function handle(UserLogin $event) &#123; &#125;&#125; app/Lisenter/DoSomething2.php 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Lisenter;use App\\Events\\UserLogin;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;class DoSomething2&#123; /** * Create the event listener. * * @return void */ public function __construct() &#123; // &#125; /** * Handle the event. * * @param UserLogin $event * @return void */ public function handle(UserLogin $event) &#123; &#125;&#125; 在两个监听器的handle方法中，增加实现测试app/Lisenter/DoSomething1.php 1234567891011/** * Handle the event. * * @param UserLogin $event * @return void */public function handle(UserLogin $event)&#123; // info('something1 :'.serialize($event));&#125; app/Lisenter/DoSomething2.php 1234567891011/** * Handle the event. * * @param UserLogin $event * @return void */public function handle(UserLogin $event)&#123; // info('something2 :'.serialize($event));&#125; 添加调用1event(new App\\Events\\UserLogin()); 调用结果12[2019-09-26 06:17:41] local.INFO: something1 :O:20:\"App\\Events\\UserLogin\":1:&#123;s:6:\"socket\";N;&#125; [2019-09-26 06:17:41] local.INFO: something2 :O:20:\"App\\Events\\UserLogin\":1:&#123;s:6:\"socket\";N;&#125; 从上发现这个监听机制能正常工作了已经。 添加队列异步处理此时分发和触发事件都是实时触发的，如果需要异步处理则需要配置一下队列信息了。比如把上面的DoSomething1改成需要放入队列的，只需要 implements Illuminate\\Contracts\\Queue\\ShouldQueue。同时指定队列驱动信息，如下代码。 12345678910111213/** * 任务应该发送到的队列的连接的名称 * * @var string|null */public $connection = 'redis';/** * 任务应该发送到的队列的名称 * * @var string|null */public $queue = 'listeners'; 我们再次运行控制脚本，发现只打印了something2， 没有打印something1，此时去redis里面发现多了两个list，如下: 1234567127.0.0.1:6379&gt; keys *1) &quot;laravel_database_queues:listeners:notify&quot;2) &quot;laravel_database_queues:listeners&quot;127.0.0.1:6379&gt; LRANGE laravel_database_queues:listeners:notify 0 -11) &quot;1&quot;127.0.0.1:6379&gt; LRANGE laravel_database_queues:listeners 0 -11) &quot;&#123;\\&quot;displayName\\&quot;:\\&quot;App\\\\\\\\Lisenter\\\\\\\\DoSomething1\\&quot;,\\&quot;job\\&quot;:\\&quot;Illuminate\\\\\\\\Queue\\\\\\\\CallQueuedHandler@call\\&quot;,\\&quot;maxTries\\&quot;:null,\\&quot;delay\\&quot;:null,\\&quot;timeout\\&quot;:null,\\&quot;timeoutAt\\&quot;:null,\\&quot;data\\&quot;:&#123;\\&quot;commandName\\&quot;:\\&quot;Illuminate\\\\\\\\Events\\\\\\\\CallQueuedListener\\&quot;,\\&quot;command\\&quot;:\\&quot;O:36:\\\\\\&quot;Illuminate\\\\\\\\Events\\\\\\\\CallQueuedListener\\\\\\&quot;:7:&#123;s:5:\\\\\\&quot;class\\\\\\&quot;;s:25:\\\\\\&quot;App\\\\\\\\Lisenter\\\\\\\\DoSomething1\\\\\\&quot;;s:6:\\\\\\&quot;method\\\\\\&quot;;s:6:\\\\\\&quot;handle\\\\\\&quot;;s:4:\\\\\\&quot;data\\\\\\&quot;;a:1:&#123;i:0;O:20:\\\\\\&quot;App\\\\\\\\Events\\\\\\\\UserLogin\\\\\\&quot;:1:&#123;s:6:\\\\\\&quot;socket\\\\\\&quot;;N;&#125;&#125;s:5:\\\\\\&quot;tries\\\\\\&quot;;N;s:9:\\\\\\&quot;timeoutAt\\\\\\&quot;;N;s:7:\\\\\\&quot;timeout\\\\\\&quot;;N;s:6:\\\\\\&quot;\\\\u0000*\\\\u0000job\\\\\\&quot;;N;&#125;\\&quot;&#125;,\\&quot;id\\&quot;:\\&quot;NXhiqRYQNaZJTYHfkwPZzPdztmEk7Nmd\\&quot;,\\&quot;attempts\\&quot;:0&#125;&quot; 这个时候需要使用php artisan queue:work redis --queue=listeners执行队列任务，才是真正执行something1这个监听器的handle方法。 参考链接事件系统队列","categories":[{"name":"php","slug":"php","permalink":"http://shiwenyuan.github.io/categories/php/"},{"name":"laravel","slug":"php/laravel","permalink":"http://shiwenyuan.github.io/categories/php/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://shiwenyuan.github.io/tags/laravel/"}]},{"title":"Laravel-job简单使用","slug":"Laravel-job简单使用","date":"2019-09-26T04:19:45.000Z","updated":"2019-09-26T05:58:19.065Z","comments":true,"path":"post/ck107czpv00008hfylaa7d6pf.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czpv00008hfylaa7d6pf.html","excerpt":"","text":"前言1看之前需要明白队列生产者消费者基础概念，如果不了解的话可以去文章尾部的参考文档中查看 job1Laravel 队列为不同的后台队列服务提供统一的 API，例如 Beanstalk，Amazon SQS，Redis，甚至其他基于关系型数据库的队列。队列的目的是将耗时的任务延时处理，比如发送邮件，从而大幅度缩短 Web 请求和响应的时间。 队列配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//在你的`config/queue.php` 配置文件里，有一个`connections`配置选项，此处以redis举例&lt;?phpreturn [ /* |-------------------------------------------------------------------------- | Default Queue Connection Name |-------------------------------------------------------------------------- | | Laravel's queue API supports an assortment of back-ends via a single | API, giving you convenient access to each back-end using the same | syntax for every one. Here you may define a default connection. | */ 'default' =&gt; env('QUEUE_CONNECTION', 'sync'), /* |-------------------------------------------------------------------------- | Queue Connections |-------------------------------------------------------------------------- | | Here you may configure the connection information for each server that | is used by your application. A default configuration has been added | for each back-end shipped with Laravel. You are free to add more. | | Drivers: \"sync\", \"database\", \"beanstalkd\", \"sqs\", \"redis\", \"null\" | */ 'connections' =&gt; [ 'sync' =&gt; [ 'driver' =&gt; 'sync', ], 'database' =&gt; [ 'driver' =&gt; 'database', 'table' =&gt; 'jobs', 'queue' =&gt; 'default', 'retry_after' =&gt; 90, ], 'beanstalkd' =&gt; [ 'driver' =&gt; 'beanstalkd', 'host' =&gt; 'localhost', 'queue' =&gt; 'default', 'retry_after' =&gt; 90, 'block_for' =&gt; 0, ], 'sqs' =&gt; [ 'driver' =&gt; 'sqs', 'key' =&gt; env('AWS_ACCESS_KEY_ID'), 'secret' =&gt; env('AWS_SECRET_ACCESS_KEY'), 'prefix' =&gt; env('SQS_PREFIX', 'https://sqs.us-east-1.amazonaws.com/your-account-id'), 'queue' =&gt; env('SQS_QUEUE', 'your-queue-name'), 'region' =&gt; env('AWS_DEFAULT_REGION', 'us-east-1'), ], 'redis' =&gt; [ 'driver' =&gt; 'redis', 'connection' =&gt; 'default', 'queue' =&gt; env('REDIS_QUEUE', 'default'), 'retry_after' =&gt; 90, 'block_for' =&gt; null, ], ], /* |-------------------------------------------------------------------------- | Failed Queue Jobs |-------------------------------------------------------------------------- | | These options configure the behavior of failed queue job logging so you | can control which database and table are used to store the jobs that | have failed. You may change them to any database / table you wish. | */ 'failed' =&gt; [ 'driver' =&gt; env('QUEUE_FAILED_DRIVER', 'database'), 'database' =&gt; env('DB_CONNECTION', 'mysql'), 'table' =&gt; 'failed_jobs', ],]; 生成job文件php artisan make:job JobMonitorOrder此条命令会在生成如下文件 123456789101112131415161718192021222324252627282930313233➜ cat app/Jobs/JobMonitorOrder.php&lt;?phpnamespace App\\Jobs;use Illuminate\\Bus\\Queueable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;/** * Class JobMonitorOrder * @package App\\Jobs */class JobMonitorOrder implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; /** * Create a new job instance. */ public function __construct() &#123; &#125; /** * @return void */ public function handle() &#123; &#125;&#125; 修改实现12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\\Jobs;use Illuminate\\Bus\\Queueable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;/** * Class JobMonitorOrder * @package App\\Jobs */class JobMonitorOrder implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; /** * @var null */ public $order_id = null; /** * Create a new job instance. * @param $order_id */ public function __construct($order_id) &#123; $this-&gt;order_id = $order_id; &#125; /** * @return bool */ public function handle() &#123; info('shiwenyuan test order_id:'.$this-&gt;order_id); return true; &#125;&#125; 生产者调用方式1\\App\\Jobs\\JobMonitorOrder::dispatch('123131231231')-&gt;allOnConnection('redis'); 执行结果执行后会插入到队列中 1234567891011➜ fundta-monitor git:(feature_01_order_monitor) ✗ redis-cli127.0.0.1:6379&gt; keys *1) &quot;laravel_database_queues:default&quot;2) &quot;laravel_database_queues:default:notify&quot;127.0.0.1:6379&gt; type laravel_database_queues:default:notifylist127.0.0.1:6379&gt; LRANGE laravel_database_queues:default:notify 0 -11) &quot;1&quot;127.0.0.1:6379&gt; LRANGE laravel_database_queues:default 0 -11) &quot;&#123;\\&quot;displayName\\&quot;:\\&quot;App\\\\\\\\Jobs\\\\\\\\JobMonitorOrder\\&quot;,\\&quot;job\\&quot;:\\&quot;Illuminate\\\\\\\\Queue\\\\\\\\CallQueuedHandler@call\\&quot;,\\&quot;maxTries\\&quot;:null,\\&quot;delay\\&quot;:null,\\&quot;timeout\\&quot;:null,\\&quot;timeoutAt\\&quot;:null,\\&quot;data\\&quot;:&#123;\\&quot;commandName\\&quot;:\\&quot;App\\\\\\\\Jobs\\\\\\\\JobMonitorOrder\\&quot;,\\&quot;command\\&quot;:\\&quot;O:24:\\\\\\&quot;App\\\\\\\\Jobs\\\\\\\\JobMonitorOrder\\\\\\&quot;:9:&#123;s:8:\\\\\\&quot;order_id\\\\\\&quot;;s:12:\\\\\\&quot;123131231231\\\\\\&quot;;s:6:\\\\\\&quot;\\\\u0000*\\\\u0000job\\\\\\&quot;;N;s:10:\\\\\\&quot;connection\\\\\\&quot;;s:5:\\\\\\&quot;redis\\\\\\&quot;;s:5:\\\\\\&quot;queue\\\\\\&quot;;N;s:15:\\\\\\&quot;chainConnection\\\\\\&quot;;s:5:\\\\\\&quot;redis\\\\\\&quot;;s:10:\\\\\\&quot;chainQueue\\\\\\&quot;;N;s:5:\\\\\\&quot;delay\\\\\\&quot;;N;s:10:\\\\\\&quot;middleware\\\\\\&quot;;a:0:&#123;&#125;s:7:\\\\\\&quot;chained\\\\\\&quot;;a:0:&#123;&#125;&#125;\\&quot;&#125;,\\&quot;id\\&quot;:\\&quot;f8srlRRzDN4CLjw1WS96p8xTo4z4jGcr\\&quot;,\\&quot;attempts\\&quot;:0&#125;&quot;127.0.0.1:6379&gt; LRANGE laravel_database_queues:default:notify 0 -1 消费者调用方式另启动一个cli进程开启消费者，此时看到消费者在从队列里消费投递的任务 123➜ fundta-monitor git:(feature_01_order_monitor) ✗ php artisan queue:work redis[2019-09-26 05:53:10][f8srlRRzDN4CLjw1WS96p8xTo4z4jGcr] Processing: App\\Jobs\\JobMonitorOrder[2019-09-26 05:53:10][f8srlRRzDN4CLjw1WS96p8xTo4z4jGcr] Processed: App\\Jobs\\JobMonitorOrder 执行结果刚刚那个job是往日志文件中插入一条记录，此时打开日志去查看 1[2019-09-26 05:53:10] local.INFO: shiwenyuan test order_id:123131231231 参考文档队列《laravel6》队列生产者消费者基础概念","categories":[{"name":"php","slug":"php","permalink":"http://shiwenyuan.github.io/categories/php/"},{"name":"laravel","slug":"php/laravel","permalink":"http://shiwenyuan.github.io/categories/php/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://shiwenyuan.github.io/tags/laravel/"}]},{"title":"Php-将变量输出成array结构","slug":"Php-将变量输出成array结构","date":"2019-09-11T11:26:15.000Z","updated":"2019-09-16T02:49:59.325Z","comments":true,"path":"post/ck107czqn00088hfy14tj4qcx.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czqn00088hfy14tj4qcx.html","excerpt":"","text":"前言今天写需求的时候遇到个问题，前端给了我一段json，需要我配置到php项目里面，而我则需要去把它变成array。虽然用的时候可以直接json_decode但是感觉还是会损失一定的性能，而一个个去改的话又觉得很麻烦，所以写了一段下面的代码，可以让json自动转换成array，这样配置的时候可以直接cp输出内容去配置，用起来也比较方便 outPutArray12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?php/** * Created by PhpStorm. * User: shiwenyuan * Date: 2019/9/11 13341007105@163.com * Time: 17:33 */class Utils&#123; /** * 把array或json以array字符串的形式输出 等同于var_export * @param $str * @return string */ public static function outPutArray($str): string &#123; if (is_string($str)) &#123; $arr = json_decode($str, true); if (is_null($arr)) &#123; $ret_str = ''; if (is_numeric($str)) &#123; $ret_str .= '[' .PHP_EOL. $str .PHP_EOL. ']'; &#125; else &#123; $ret_str .= '[' .PHP_EOL. '\\''.$str .'\\''.PHP_EOL. ']'; &#125; return $ret_str; &#125; &#125; else &#123; $arr = $str; &#125; $str = '[' . PHP_EOL; foreach ($arr as $key =&gt; $value) &#123; if (!is_numeric($key)) &#123; $str .= \"'&#123;$key&#125;' =&gt; \"; &#125; if (is_array($value)) &#123; $str .= self::outPutArray($value); &#125; else &#123; if (is_string($value)) &#123; $str .= \"'&#123;$value&#125;',\" . PHP_EOL; &#125; else &#123; $str .= \"&#123;$value&#125;,\" . PHP_EOL; &#125; &#125; &#125; $str .= '],' . PHP_EOL; return $str; &#125;&#125;echo Utils::outPutArray('shiwenyuan');/* * [ * 'shiwenyuan' * ] * */echo Utils::outPutArray(['name'=&gt;'zhangsan', 'age'=&gt;18, 'friend'=&gt;[['name'=&gt;'lisi', 'age'=&gt;19], ['name'=&gt;'wangwu', 'age'=&gt;20]]]);/** * [ *'name' =&gt; 'zhangsan', * 'age' =&gt; 18, * 'friend' =&gt; [ * [ * 'name' =&gt; 'lisi', * 'age' =&gt; 19, * ], * [ * 'name' =&gt; 'wangwu', * 'age' =&gt; 20, * ], * ], * ] */echo Utils::outPutArray('&#123;\"name\":\"zhangsan\",\"age\":18,\"friend\":[&#123;\"name\":\"lisi\",\"age\":19&#125;,&#123;\"name\":\"wangwu\",\"age\":21&#125;]&#125;');/** * [ *'name' =&gt; 'zhangsan', * 'age' =&gt; 18, * 'friend' =&gt; [ * [ * 'name' =&gt; 'lisi', * 'age' =&gt; 19, * ], * [ * 'name' =&gt; 'wangwu', * 'age' =&gt; 20, * ], * ], * ] */","categories":[{"name":"代码片段","slug":"代码片段","permalink":"http://shiwenyuan.github.io/categories/代码片段/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"http://shiwenyuan.github.io/tags/代码片段/"}]},{"title":"Nginx配置移动端和电脑端自动双向跳转","slug":"Nginx配置移动端和电脑端自动双向跳转","date":"2019-09-04T08:49:04.000Z","updated":"2019-09-10T08:55:18.190Z","comments":true,"path":"post/ck107czqh00068hfym9qbidgk.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czqh00068hfym9qbidgk.html","excerpt":"","text":"场景 端 域名 描述 pc端 www.phpblog.com.cn 用于pc端访问官网 移动端 m.phpblog.com.cn 用于移动端访问 需求1在移动端访问www.phpblog.com.cn和m.phpblog.com.cn都跳转到m.phpblog.com.cn 实现方案12判断客户端的设备类型要想让网站适配PC和手机设备，首先要能做出准确的判断。HTTP请求的Header中的User-Agent可以区分客户端的浏览器类型，可以通过User-Agent来判断客户端的设备。 nginx原始配置pc配置12345678server &#123; listen 80; server_name www.phpblog.com.cn; location / &#123; root www; index index.html index.htm; &#125;&#125; 移动端配置12345678server &#123; listen 80; server_name m.phpblog.com.cn; location / &#123; root m; index index.html index.htm; &#125;&#125; m/index.html www/index.html nginx修改后配置pc配置1234567891011server &#123; listen 80; server_name www.phpblog.com.cn; if ($http_user_agent ~* (mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) &#123; rewrite ^(.*) http://m.phpblog.com.cn$1 permanent; &#125; location / &#123; root www; index index.html index.htm; &#125;&#125; 移动端配置1234567891011server &#123; listen 80; server_name m.phpblog.com.cn; if ($http_user_agent !~* (mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) &#123; rewrite ^(.*) http://www.phpblog.com.cn$1 permanent; &#125; location / &#123; root m; index index.html index.htm; &#125;&#125; 此时在pc访问m.phpblog.com.cn 1可以看到有两次http请求第一次请求m.phpblog.com.cn发生了一次重定向 ，重定向到到了www.phpblog.com.cn 此时在pc访问www.phpblog.com.cn 1可以看到有一次http请求第一次请求 此时在移动端访问m.phpblog.com.cn 1可以看到有一次http请求第一次请求 此时在移动端访问www.phpblog.com.cn 1可以看到有两次http请求第一次请求www.phpblog.com.cn发生了一次重定向,，重定向到到了 m.phpblog.com.cn 原理1nginx 利用每次http请求过来的浏览器ua来区分是移动端还是pc，然后做相应的跳转 相关文档百度的官方建议国外开源的通过User-Agent区分PC和手机的解决方案","categories":[{"name":"nginx","slug":"nginx","permalink":"http://shiwenyuan.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://shiwenyuan.github.io/tags/nginx/"}]},{"title":"分享一款图床工具PicGo","slug":"分享一款图床工具PicGo","date":"2019-08-28T08:48:56.000Z","updated":"2019-09-10T08:55:33.474Z","comments":true,"path":"post/ck107czr3000f8hfylxj9a9gi.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czr3000f8hfylxj9a9gi.html","excerpt":"","text":"什么是图床概念图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。 摘选自百度百科 意义就是专门用来存放图片，同时允许你把图片对外连接的网上空间，不少图床都是免费的。 摘选自百度百科 为什么用图床工具近年来越来越多的博客支持markdown文档，但是其中想要插入图片的话却只能插入图片的链接。大的技术分享网站都会支持图片的复制自动上传(比如laravel-china,掘金，简书…)，但是为了防止盗取流量，一般都配置的有防盗链，如果你想在自己的博客网站上亦或者自己的笔记中使用的话，就不能满足了，只能存在第三方的对象存储中（自有服务器除外），而这些上传又比较麻烦，所以延伸出来了图床工具 常见图床工具iPic默认上传到微博，不过有时会上传失败，但是别的方式都是需要收费才能开通，而且还都是需要去第三方实名认证之后。 PicGo此处我用的是github PicGo配置sm.ms图床配置项此处不需要配置，只用去设置为默认图床即可 github图床配置项 其中带*为必填项 1、仓库名: 这个没有什么好说的，就是github仓库地址，比如我的图床仓库地址是github.com/shiwenyuan/pic 此处填写的就是shiwenyuan/pic 2、设定分支名称: 这个也没有什么好说的，就是github仓库地址的分支，此处我用的是master分支 3、设定token: token指的是你github账户的token(token生成地址,需注意一点：生成token时要☑️repo项，该项是允许提交代码库)，就是github仓库地址的分支，此处我用的是master分支 其他图床配置项基本就是在第三方平台上面注册一个账号，开通对象存储得到app_id,app_secret，然后配置到图床服务中即可 至此已配置完成 使用流程除了上图的两种方式，同时也支持拖拽到状态栏图标上传 ps: 个人比较喜欢剪切板图片上传，代码截图不用保存到本地，之前上传一直都是代码截图-&gt;保存到本地-&gt;上传到图床-&gt;删除截图文件，现在就直接代码截图-&gt;点击剪贴板上传就可以了，中途不会产生多余的图片文件在自己的开发机上面。 结语为Molunerfinn点赞 PicGo传送门: PicGo 原文出处: https://shiwenyuan.github.io/post/cjzwb8x8f0002ugs6yap15758.html","categories":[{"name":"系统工具","slug":"系统工具","permalink":"http://shiwenyuan.github.io/categories/系统工具/"},{"name":"mac","slug":"系统工具/mac","permalink":"http://shiwenyuan.github.io/categories/系统工具/mac/"}],"tags":[{"name":"系统工具","slug":"系统工具","permalink":"http://shiwenyuan.github.io/tags/系统工具/"}]},{"title":"每个 PHPer 都应当掌握的注释标记","slug":"每个-PHPer-都应当掌握的注释标记","date":"2019-08-27T08:48:48.000Z","updated":"2019-09-10T09:07:23.320Z","comments":true,"path":"post/ck107czrf000j8hfycf8yhqfk.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czrf000j8hfycf8yhqfk.html","excerpt":"","text":"前言注释标签在代码注释中的作用非常大，好的找注释标签可以让你在编程过程中有更好、更舒适的体验，所以我今天准备整理一下这些标记，通过图文的形式展示出来，一方面是为了自己对这些注释标签有一个汇总整理，另一方面也希望大家能够更好对理解注释标签 每个人都希望写出漂亮的代码，或许你离漂亮的代码，就差一个标签 常用标签 标记 用途 描述 @abstract 抽象类的变量和方法 @access public, private or protected 文档的访问、使用权限. @access private 表明这个文档是被保护的。 @author 张三 &#x7a;&#104;&#97;&#x6e;&#103;&#115;&#97;&#110;&#64;&#49;&#54;&#51;&#46;&#x63;&#111;&#109; 文档作者 @copyright 名称 时间 文档版权信息 @deprecated version 文档中被废除的方法 @deprec 同 @deprecated @example /path/to/example 文档的外部保存的示例文件的位置。 @exception 文档中方法抛出的异常，也可参照 @throws. @global 类型：$globalvarname 文档中的全局变量及有关的方法和函数 @ignore 忽略文档中指定的关键字 @internal 开发团队内部信息 @link URL 类似于license 但还可以通过link找到文档中的更多个详细的信息 @name 变量别名 为某个变量指定别名 @magic phpdoc.de compatibility @package 封装包的名称 一组相关类、函数封装的包名称 @param 如 $username 用户名 变量含义注释 @return 如 返回bool 函数返回结果描述，一般不用在void（空返回结果的）的函数中 @see 如 Class Login() 文件关联的任何元素（全局变量，包括，页面，类，函数，定义，方法，变量）。 @since version 记录什么时候对文档的哪些部分进行了更改 @static 记录静态类、方法 @staticvar 在类、函数中使用的静态变量 @subpackage 子版本 @throws 某一方法抛出的异常 @todo 表示文件未完成或者要完善的地方 @var type 文档中的变量及其类型 @version 文档、类、函数的版本信息 上面这么多其实很大一部分都是创建文件、创建类的时候需要添加的。今天主要讲解一下常用的标签。 @param说明参数，用于函数和方法注释里的标记格式@param [Type] [name] [&lt;description&gt;]例如@param string title 文章标题 代码举例 @return说明返回值格式@return [类型] [&lt;描述&gt;]]例如@return array 结果数组 代码举例 @deprecated说明不建议使用的、已过期的、将被删除的格式@deprecated [&lt;版本号&gt;] [&lt;描述&gt;]例如@deprecated 1.0.0 新版本将不再包含此函数如果它是被其他方法所取代了，建议添加@see标记 代码举例 @see说明参考，类似@link，可与@deprecated联动格式@see [url或完整方法名] [&lt;描述&gt;]例如@see \\yii\\base\\db::tableName() 旧方法table_name已弃用，请使用此方法替代 代码举例 @link说明链接，可用于辅助说明、引用文档等格式@link [url] [&lt;描述&gt;]例如@link http://g.cn 不懂滚去问谷歌，别来烦我 代码举例 @link&amp;@see区别 - @see @link 外部链接 √ √ 内部程序 √ X @var说明变量格式@var [类型] [变量名] [&lt;描述&gt;]例如@var int id 用户id 变量列表 变量类型 说明 string 字符串 integer/int number/int类型 boolean/bool false/true float/double number/浮点数 object 对象实例 specifiedType 指定类 mixed 任意类型 array/specifiedType[] 数组，可以指定成指定类型的数组 resource 文件资源类型 void 无返回值 null - callable 可执行的回调函数 function 不一定能执行的方法 self/$this 当前实例 代码举例1、在方法外的变量定义2、在方法内的变量定义 @throws说明可能会抛出的错误类型格式@throws [类型] [&lt;描述&gt;]例如@throws Exception","categories":[{"name":"代码规范","slug":"代码规范","permalink":"http://shiwenyuan.github.io/categories/代码规范/"}],"tags":[{"name":"php","slug":"php","permalink":"http://shiwenyuan.github.io/tags/php/"},{"name":"代码规范","slug":"代码规范","permalink":"http://shiwenyuan.github.io/tags/代码规范/"}]},{"title":"PhpStorm集成PlantUML","slug":"PhpStorm集成PlantUML","date":"2019-08-23T08:48:36.000Z","updated":"2019-09-10T08:56:43.735Z","comments":true,"path":"post/ck107czqs000a8hfyrng6yoeo.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czqs000a8hfyrng6yoeo.html","excerpt":"","text":"前言工作到现在一直在一味的去学习、去工作、去coding，从而忽略了对自己对技能的总结。近来工作比较清闲，所以就准备把自己的作为程序员的技能栈好好梳理一下，就先从设计模式开始了！！！ 设计模式相关文章内容构想 该设计模式的应用场景 该设计模式的uml图 该设计模式的代码实现 相关代码届时会放到github提到了uml、市面上可以画uml图的工具有很多，诸如starUML、plantuml… 但是我还是更喜欢在PhpStorm里面去操作 phpstrom插件下载PhpStrom-&gt;Perferences-&gt;Plugins-&gt;搜索PlantUML-&gt;install(位置是在下图的Restart PhpStorm，此处我是install了之后，显示让我从启动的，哈哈哈哈哈)下载成功之后点击上图位置的Restart PhpStorm，重新打开之后点击创建文件，这时就会出现uml相关文件的创建 创建文件创建uml class，这时发现右侧的显示时一段error提示，大致意思就是需要装一个graphviz软件 安装graphviz我是本机是mac所以我用brew,windows用户需自己找一下exe文件安装，此处不一一赘述安装成功后找到安装包可执行文件位置配置Phpstrom此处我的安装包可执行文件位置就是/usr/local/bin/dot 配置phpstrom回到原uml文件点击刷新、大功告成 相关文档plantuml语法","categories":[{"name":"编程ide","slug":"编程ide","permalink":"http://shiwenyuan.github.io/categories/编程ide/"}],"tags":[{"name":"编程ide","slug":"编程ide","permalink":"http://shiwenyuan.github.io/tags/编程ide/"}]},{"title":"PHP-代码整洁之道","slug":"PHP-代码整洁之道","date":"2019-08-19T08:48:42.000Z","updated":"2019-09-10T09:07:46.962Z","comments":true,"path":"post/ck107czul001e8hfyqmzczd93.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czul001e8hfyqmzczd93.html","excerpt":"","text":"前言 文章出处 https://github.com/php-cpm/clean-code-php Clean Code PHP目录 介绍 变量 使用见字知意的变量名 同一个实体要用相同的变量名 使用便于搜索的名称 (part 1) 使用便于搜索的名称 (part 2) 使用自解释型变量 避免深层嵌套，尽早返回 (part 1) 避免深层嵌套，尽早返回 (part 2) 少用无意义的变量名 不要添加不必要上下文 合理使用参数默认值，没必要在方法里再做默认值检测 表达式 使用恒等式 函数 函数参数（最好少于2个） 函数应该只做一件事 函数名应体现他做了什么事 函数里应当只有一层抽象abstraction 不要用flag作为函数的参数 避免副作用 不要写全局函数 不要使用单例模式 封装条件语句 避免用反义条件判断 避免条件判断 避免类型检查 (part 1) 避免类型检查 (part 2) 移除僵尸代码 对象和数据结构 Objects and Data Structures 使用 getters 和 setters Use object encapsulation 给对象使用私有或受保护的成员变量 类 少用继承多用组合 避免连贯接口 推荐使用 final 类 类的SOLID原则 SOLID S: 单一职责原则 Single Responsibility Principle (SRP) O: 开闭原则 Open/Closed Principle (OCP) L: 里氏替换原则 Liskov Substitution Principle (LSP) I: 接口隔离原则 Interface Segregation Principle (ISP) D: 依赖倒置原则 Dependency Inversion Principle (DIP) 别写重复代码 (DRY) 翻译 介绍本文参考自 Robert C. Martin的Clean Code 书中的软件工程师的原则,适用于PHP。 这不是风格指南。 这是一个关于开发可读、可复用并且可重构的PHP软件指南。 并不是这里所有的原则都得遵循，甚至很少的能被普遍接受。 这些虽然只是指导，但是都是Clean Code作者多年总结出来的。 本文受到 clean-code-javascript 的启发 虽然很多开发者还在使用PHP5，但是本文中的大部分示例的运行环境需要PHP 7.1+。 翻译说明翻译完成度100%，最后更新时间2017-12-25。本文由 php-cpm 基于 yangweijie版本 的clean-code-php翻译并同步大量原文内容。 原文更新频率较高，我的翻译方法是直接用文本比较工具逐行对比。优先保证文字内容是最新的，再逐步提升翻译质量。 阅读过程中如果遇到各种链接失效、内容老旧、术语使用错误和其他翻译错误等问题，欢迎大家积极提交PR。 变量使用见字知意的变量名坏: 1$ymdstr = $moment-&gt;format('y-m-d'); 好: 1$currentDate = $moment-&gt;format('y-m-d'); ⬆ 返回顶部 同一个实体要用相同的变量名坏: 1234getUserInfo();getUserData();getUserRecord();getUserProfile(); 好: 1getUser(); ⬆ 返回顶部 使用便于搜索的名称 (part 1)写代码是用来读的。所以写出可读性高、便于搜索的代码至关重要。命名变量时如果没有有意义、不好理解，那就是在伤害读者。请让你的代码便于搜索。 坏: 12// What the heck is 448 for?$result = $serializer-&gt;serialize($data, 448); 好: 1$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE); 使用便于搜索的名称 (part 2)坏: 1234// What the heck is 4 for?if ($user-&gt;access &amp; 4) &#123; // ...&#125; 好: 1234567891011class User&#123; const ACCESS_READ = 1; const ACCESS_CREATE = 2; const ACCESS_UPDATE = 4; const ACCESS_DELETE = 8;&#125;if ($user-&gt;access &amp; User::ACCESS_UPDATE) &#123; // do edit ...&#125; ⬆ 返回顶部 使用自解释型变量坏: 12345$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\\s*(.+?)\\s*(\\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches[1], $matches[2]); 不错: 好一些，但强依赖于正则表达式的熟悉程度 123456$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\\s*(.+?)\\s*(\\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);[, $city, $zipCode] = $matches;saveCityZipCode($city, $zipCode); 好: 使用带名字的子规则，不用懂正则也能看的懂 12345$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\\s*(?&lt;city&gt;.+?)\\s*(?&lt;zipCode&gt;\\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches['city'], $matches['zipCode']); ⬆ 返回顶部 避免深层嵌套，尽早返回 (part 1)太多的if else语句通常会导致你的代码难以阅读，直白优于隐晦 糟糕: 123456789101112131415161718192021function isShopOpen($day): bool&#123; if ($day) &#123; if (is_string($day)) &#123; $day = strtolower($day); if ($day === 'friday') &#123; return true; &#125; elseif ($day === 'saturday') &#123; return true; &#125; elseif ($day === 'sunday') &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; 好: 123456789101112function isShopOpen(string $day): bool&#123; if (empty($day)) &#123; return false; &#125; $openingDays = [ 'friday', 'saturday', 'sunday' ]; return in_array(strtolower($day), $openingDays, true);&#125; ⬆ 返回顶部 避免深层嵌套，尽早返回 (part 2)糟糕的: 12345678910111213141516function fibonacci(int $n)&#123; if ($n &lt; 50) &#123; if ($n !== 0) &#123; if ($n !== 1) &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; return 'Not supported'; &#125;&#125; 好: 123456789101112function fibonacci(int $n): int&#123; if ($n === 0 || $n === 1) &#123; return $n; &#125; if ($n &gt; 50) &#123; throw new \\Exception('Not supported'); &#125; return fibonacci($n - 1) + fibonacci($n - 2);&#125; ⬆ 返回顶部 少用无意义的变量名别让读你的代码的人猜你写的变量是什么意思。写清楚好过模糊不清。 坏: 123456789101112$l = ['Austin', 'New York', 'San Francisco'];for ($i = 0; $i &lt; count($l); $i++) &#123; $li = $l[$i]; doStuff(); doSomeOtherStuff(); // ... // ... // ... // 等等, `$li` 又代表什么? dispatch($li);&#125; 好: 12345678910$locations = ['Austin', 'New York', 'San Francisco'];foreach ($locations as $location) &#123; doStuff(); doSomeOtherStuff(); // ... // ... // ... dispatch($location);&#125; ⬆ 返回顶部 不要添加不必要上下文如果从你的类名、对象名已经可以得知一些信息，就别再在变量名里重复。 坏: 12345678class Car&#123; public $carMake; public $carModel; public $carColor; //...&#125; 好: 12345678class Car&#123; public $make; public $model; public $color; //...&#125; ⬆ 返回顶部 合理使用参数默认值，没必要在方法里再做默认值检测不好: 不好，$breweryName 可能为 NULL. 1234function createMicrobrewery($breweryName = 'Hipster Brew Co.'): void&#123; // ...&#125; 还行: 比上一个好理解一些，但最好能控制变量的值 12345function createMicrobrewery($name = null): void&#123; $breweryName = $name ?: 'Hipster Brew Co.'; // ...&#125; 好: 如果你的程序只支持 PHP 7+, 那你可以用 type hinting 保证变量 $breweryName 不是 NULL. 1234function createMicrobrewery(string $breweryName = 'Hipster Brew Co.'): void&#123; // ...&#125; ⬆ 返回顶部 表达式使用恒等式不好: 简易对比会将字符串转为整形 123456$a = '42';$b = 42;if( $a != $b ) &#123; //这里始终执行不到&#125; 对比 $a != $b 返回了 FALSE 但应该返回 TRUE !字符串 ‘42’ 跟整数 42 不相等 好: 使用恒等判断检查类型和数据 123456$a = '42';$b = 42;if ($a !== $b) &#123; // The expression is verified&#125; The comparison $a !== $b returns TRUE. ⬆ 返回顶部 函数函数参数（最好少于2个）限制函数参数个数极其重要，这样测试你的函数容易点。有超过3个可选参数参数导致一个爆炸式组合增长，你会有成吨独立参数情形要测试。 无参数是理想情况。1个或2个都可以，最好避免3个。再多就需要加固了。通常如果你的函数有超过两个参数，说明他要处理的事太多了。 如果必须要传入很多数据，建议封装一个高级别对象作为参数。 坏: 1234function createMenu(string $title, string $body, string $buttonText, bool $cancellable): void&#123; // ...&#125; 好: 123456789101112131415161718class MenuConfig&#123; public $title; public $body; public $buttonText; public $cancellable = false;&#125;$config = new MenuConfig();$config-&gt;title = 'Foo';$config-&gt;body = 'Bar';$config-&gt;buttonText = 'Baz';$config-&gt;cancellable = true;function createMenu(MenuConfig $config): void&#123; // ...&#125; ⬆ 返回顶部 函数应该只做一件事这是迄今为止软件工程里最重要的一个规则。当一个函数做超过一件事的时候，他们就难于实现、测试和理解。当你把一个函数拆分到只剩一个功能时，他们就容易被重构，然后你的代码读起来就更清晰。如果你光遵循这条规则，你就领先于大多数开发者了。 坏: 123456789function emailClients(array $clients): void&#123; foreach ($clients as $client) &#123; $clientRecord = $db-&gt;find($client); if ($clientRecord-&gt;isActive()) &#123; email($client); &#125; &#125;&#125; 好: 1234567891011121314151617function emailClients(array $clients): void&#123; $activeClients = activeClients($clients); array_walk($activeClients, 'email');&#125;function activeClients(array $clients): array&#123; return array_filter($clients, 'isClientActive');&#125;function isClientActive(int $client): bool&#123; $clientRecord = $db-&gt;find($client); return $clientRecord-&gt;isActive();&#125; ⬆ 返回顶部 函数名应体现他做了什么事坏: 12345678910111213class Email&#123; //... public function handle(): void &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 啥？handle处理一个消息干嘛了？是往一个文件里写吗？$message-&gt;handle(); 好: 12345678910111213class Email &#123; //... public function send(): void &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 简单明了$message-&gt;send(); ⬆ 返回顶部 函数里应当只有一层抽象abstraction当你抽象层次过多时时，函数处理的事情太多了。需要拆分功能来提高可重用性和易用性，以便简化测试。（译者注：这里从示例代码看应该是指嵌套过多） 坏: 1234567891011121314151617181920212223function parseBetterJSAlternative(string $code): void&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; // ... &#125; &#125; $ast = []; foreach ($tokens as $token) &#123; // lex... &#125; foreach ($ast as $node) &#123; // parse... &#125;&#125; 坏: 我们把一些方法从循环中提取出来，但是parseBetterJSAlternative()方法还是很复杂，而且不利于测试。 1234567891011121314151617181920212223242526272829303132333435function tokenize(string $code): array&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens;&#125;function lexer(array $tokens): array&#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast;&#125;function parseBetterJSAlternative(string $code): void&#123; $tokens = tokenize($code); $ast = lexer($tokens); foreach ($ast as $node) &#123; // 解析逻辑... &#125;&#125; 好: 最好的解决方案是把 parseBetterJSAlternative()方法的依赖移除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Tokenizer&#123; public function tokenize(string $code): array &#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens; &#125;&#125;class Lexer&#123; public function lexify(array $tokens): array &#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast; &#125;&#125;class BetterJSAlternative&#123; private $tokenizer; private $lexer; public function __construct(Tokenizer $tokenizer, Lexer $lexer) &#123; $this-&gt;tokenizer = $tokenizer; $this-&gt;lexer = $lexer; &#125; public function parse(string $code): void &#123; $tokens = $this-&gt;tokenizer-&gt;tokenize($code); $ast = $this-&gt;lexer-&gt;lexify($tokens); foreach ($ast as $node) &#123; // 解析逻辑... &#125; &#125;&#125; 这样我们可以对依赖做mock，并测试BetterJSAlternative::parse()运行是否符合预期。 ⬆ 返回顶部 不要用flag作为函数的参数flag就是在告诉大家，这个方法里处理很多事。前面刚说过，一个函数应当只做一件事。 把不同flag的代码拆分到多个函数里。 坏: 12345678function createFile(string $name, bool $temp = false): void&#123; if ($temp) &#123; touch('./temp/'.$name); &#125; else &#123; touch($name); &#125;&#125; 好: 123456789function createFile(string $name): void&#123; touch($name);&#125;function createTempFile(string $name): void&#123; touch('./temp/'.$name);&#125; ⬆ 返回顶部 避免副作用一个函数做了比获取一个值然后返回另外一个值或值们会产生副作用如果。副作用可能是写入一个文件，修改某些全局变量或者偶然的把你全部的钱给了陌生人。 现在，你的确需要在一个程序或者场合里要有副作用，像之前的例子，你也许需要写一个文件。你想要做的是把你做这些的地方集中起来。不要用几个函数和类来写入一个特定的文件。用一个服务来做它，一个只有一个。 重点是避免常见陷阱比如对象间共享无结构的数据，使用可以写入任何的可变数据类型，不集中处理副作用发生的地方。如果你做了这些你就会比大多数程序员快乐。 坏: 1234567891011121314// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.$name = 'Ryan McDermott';function splitIntoFirstAndLastName(): void&#123; global $name; $name = explode(' ', $name);&#125;splitIntoFirstAndLastName();var_dump($name); // ['Ryan', 'McDermott']; 好: 12345678910function splitIntoFirstAndLastName(string $name): array&#123; return explode(' ', $name);&#125;$name = 'Ryan McDermott';$newName = splitIntoFirstAndLastName($name);var_dump($name); // 'Ryan McDermott';var_dump($newName); // ['Ryan', 'McDermott']; ⬆ 返回顶部 不要写全局函数在大多数语言中污染全局变量是一个坏的实践，因为你可能和其他类库冲突并且调用你api的人直到他们捕获异常才知道踩坑了。让我们思考一种场景：如果你想配置一个数组，你可能会写一个全局函数config()，但是他可能和试着做同样事的其他类库冲突。 坏: 123456function config(): array&#123; return [ 'foo' =&gt; 'bar', ]&#125; 好: 1234567891011121314class Configuration&#123; private $configuration = []; public function __construct(array $configuration) &#123; $this-&gt;configuration = $configuration; &#125; public function get(string $key): ?string &#123; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null; &#125;&#125; 加载配置并创建 Configuration 类的实例 123$configuration = new Configuration([ 'foo' =&gt; 'bar',]); 现在你必须在程序中用 Configuration 的实例了 ⬆ 返回顶部 不要使用单例模式单例是一种 反模式. 以下是解释：Paraphrased from Brian Button: 总是被用成全局实例。They are generally used as a global instance, why is that so bad? Because you hide the dependencies of your application in your code, instead of exposing them through the interfaces. Making something global to avoid passing it around is a code smell. 违反了单一响应原则They violate the single responsibility principle: by virtue of the fact that they control their own creation and lifecycle. 导致代码强耦合They inherently cause code to be tightly coupled. This makes faking them out under test rather difficult in many cases. 在整个程序的生命周期中始终携带状态。They carry state around for the lifetime of the application. Another hit to testing since you can end up with a situation where tests need to be ordered which is a big no for unit tests. Why? Because each unit test should be independent from the other. 这里有一篇非常好的讨论单例模式的[根本问题((http://misko.hevery.com/2008/08/25/root-cause-of-singletons/)的文章，是[Misko Hevery](http://misko.hevery.com/about/) 写的。 坏: 12345678910111213141516171819202122class DBConnection&#123; private static $instance; private function __construct(string $dsn) &#123; // ... &#125; public static function getInstance(): DBConnection &#123; if (self::$instance === null) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; // ...&#125;$singleton = DBConnection::getInstance(); 好: 123456789class DBConnection&#123; public function __construct(string $dsn) &#123; // ... &#125; // ...&#125; 创建 DBConnection 类的实例并通过 DSN 配置. 1$connection = new DBConnection($dsn); 现在你必须在程序中 使用 DBConnection 的实例了 ⬆ 返回顶部 封装条件语句坏: 123if ($article-&gt;state === 'published') &#123; // ...&#125; 好: 123if ($article-&gt;isPublished()) &#123; // ...&#125; ⬆ 返回顶部 避免用反义条件判断坏: 123456789function isDOMNodeNotPresent(\\DOMNode $node): bool&#123; // ...&#125;if (!isDOMNodeNotPresent($node))&#123; // ...&#125; 好: 12345678function isDOMNodePresent(\\DOMNode $node): bool&#123; // ...&#125;if (isDOMNodePresent($node)) &#123; // ...&#125; ⬆ 返回顶部 避免条件判断这看起来像一个不可能任务。当人们第一次听到这句话是都会这么说。“没有if语句我还能做啥？” 答案是你可以使用多态来实现多种场景的相同任务。第二个问题很常见， “这么做可以，但为什么我要这么做？” 答案是前面我们学过的一个Clean Code原则：一个函数应当只做一件事。 当你有很多含有if语句的类和函数时,你的函数做了不止一件事。 记住，只做一件事。 坏: 12345678910111213141516class Airplane&#123; // ... public function getCruisingAltitude(): int &#123; switch ($this-&gt;type) &#123; case '777': return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); case 'Air Force One': return $this-&gt;getMaxAltitude(); case 'Cessna': return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125; &#125;&#125; 好: 123456789101112131415161718192021222324252627282930313233343536interface Airplane&#123; // ... public function getCruisingAltitude(): int;&#125;class Boeing777 implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); &#125;&#125;class AirForceOne implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude(); &#125;&#125;class Cessna implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125;&#125; ⬆ 返回顶部 避免类型检查 (part 1)PHP是弱类型的,这意味着你的函数可以接收任何类型的参数。有时候你为这自由所痛苦并且在你的函数渐渐尝试类型检查。有很多方法去避免这么做。第一种是统一API。 坏: 12345678function travelToTexas($vehicle): void&#123; if ($vehicle instanceof Bicycle) &#123; $vehicle-&gt;pedalTo(new Location('texas')); &#125; elseif ($vehicle instanceof Car) &#123; $vehicle-&gt;driveTo(new Location('texas')); &#125;&#125; 好: 1234function travelToTexas(Traveler $vehicle): void&#123; $vehicle-&gt;travelTo(new Location('texas'));&#125; ⬆ 返回顶部 避免类型检查 (part 2)如果你正使用基本原始值比如字符串、整形和数组，要求版本是PHP 7+，不用多态，需要类型检测，那你应当考虑类型声明或者严格模式。提供了基于标准PHP语法的静态类型。 手动检查类型的问题是做好了需要好多的废话，好像为了安全就可以不顾损失可读性。保持你的PHP 整洁，写好测试，做好代码回顾。做不到就用PHP严格类型声明和严格模式来确保安全。 坏: 12345678function combine($val1, $val2): int&#123; if (!is_numeric($val1) || !is_numeric($val2)) &#123; throw new \\Exception('Must be of type Number'); &#125; return $val1 + $val2;&#125; 好: 1234function combine(int $val1, int $val2): int&#123; return $val1 + $val2;&#125; ⬆ 返回顶部 移除僵尸代码僵尸代码和重复代码一样坏。没有理由保留在你的代码库中。如果从来没被调用过，就删掉！因为还在代码版本库里，因此很安全。 坏: 123456789101112function oldRequestModule(string $url): void&#123; // ...&#125;function newRequestModule(string $url): void&#123; // ...&#125;$request = newRequestModule($requestUrl);inventoryTracker('apples', $request, 'www.inventory-awesome.io'); 好: 1234567function requestModule(string $url): void&#123; // ...&#125;$request = requestModule($requestUrl);inventoryTracker('apples', $request, 'www.inventory-awesome.io'); ⬆ 返回顶部 对象和数据结构使用 getters 和 setters在PHP中你可以对方法使用public, protected, private 来控制对象属性的变更。 当你想对对象属性做获取之外的操作时，你不需要在代码中去寻找并修改每一个该属性访问方法 当有set对应的属性方法时，易于增加参数的验证 封装内部的表示 使用set和get时，易于增加日志和错误控制 继承当前类时，可以复写默认的方法功能 当对象属性是从远端服务器获取时，get，set易于使用延迟加载 此外，这样的方式也符合OOP开发中的开闭原则 坏: 123456789class BankAccount&#123; public $balance = 1000;&#125;$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;balance -= 100; 好: 123456789101112131415161718192021222324252627282930313233343536class BankAccount&#123; private $balance; public function __construct(int $balance = 1000) &#123; $this-&gt;balance = $balance; &#125; public function withdraw(int $amount): void &#123; if ($amount &gt; $this-&gt;balance) &#123; throw new \\Exception('Amount greater than available balance.'); &#125; $this-&gt;balance -= $amount; &#125; public function deposit(int $amount): void &#123; $this-&gt;balance += $amount; &#125; public function getBalance(): int &#123; return $this-&gt;balance; &#125;&#125;$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;withdraw($shoesPrice);// Get balance$balance = $bankAccount-&gt;getBalance(); ⬆ 返回顶部 给对象使用私有或受保护的成员变量 对public方法和属性进行修改非常危险，因为外部代码容易依赖他，而你没办法控制。对之修改影响所有这个类的使用者。 public methods and properties are most dangerous for changes, because some outside code may easily rely on them and you can’t control what code relies on them. Modifications in class are dangerous for all users of class. 对protected的修改跟对public修改差不多危险，因为他们对子类可用，他俩的唯一区别就是可调用的位置不一样，对之修改影响所有集成这个类的地方。 protected modifier are as dangerous as public, because they are available in scope of any child class. This effectively means that difference between public and protected is only in access mechanism, but encapsulation guarantee remains the same. Modifications in class are dangerous for all descendant classes. 对private的修改保证了这部分代码只会影响当前类private modifier guarantees that code is dangerous to modify only in boundaries of single class (you are safe for modifications and you won’t have Jenga effect). 所以，当你需要控制类里的代码可以被访问时才用public/protected，其他时候都用private。 可以读一读这篇 博客文章 ，Fabien Potencier写的. 坏: 123456789101112class Employee&#123; public $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;name; // Employee name: John Doe 好: 1234567891011121314151617class Employee&#123; private $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125; public function getName(): string &#123; return $this-&gt;name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;getName(); // Employee name: John Doe ⬆ 返回顶部 类少用继承多用组合正如 the Gang of Four 所著的设计模式之前所说，我们应该尽量优先选择组合而不是继承的方式。使用继承和组合都有很多好处。这个准则的主要意义在于当你本能的使用继承时，试着思考一下组合是否能更好对你的需求建模。在一些情况下，是这样的。 接下来你或许会想，“那我应该在什么时候使用继承？”答案依赖于你的问题，当然下面有一些何时继承比组合更好的说明： 你的继承表达了“是一个”而不是“有一个”的关系（人类-》动物，用户-》用户详情） 你可以复用基类的代码（人类可以像动物一样移动） 你想通过修改基类对所有派生类做全局的修改（当动物移动时，修改她们的能量消耗） 糟糕的: 12345678910111213141516171819202122232425262728293031323334class Employee &#123; private $name; private $email; public function __construct(string $name, string $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; // ...&#125;// 不好，因为 Employees \"有\" taxdata// 而 EmployeeTaxData 不是 Employee 类型的class EmployeeTaxData extends Employee &#123; private $ssn; private $salary; public function __construct(string $name, string $email, string $ssn, string $salary) &#123; parent::__construct($name, $email); $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125; 好: 123456789101112131415161718192021222324252627282930313233class EmployeeTaxData &#123; private $ssn; private $salary; public function __construct(string $ssn, string $salary) &#123; $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125;class Employee &#123; private $name; private $email; private $taxData; public function __construct(string $name, string $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function setTaxData(string $ssn, string $salary) &#123; $this-&gt;taxData = new EmployeeTaxData($ssn, $salary); &#125; // ...&#125; ⬆ 返回顶部 避免连贯接口连贯接口Fluent interface是一种旨在提高面向对象编程时代码可读性的API设计模式，他基于方法链Method chaining 有上下文的地方可以降低代码复杂度，例如PHPUnit Mock Builder和Doctrine Query Builder，更多的情况会带来较大代价： While there can be some contexts, frequently builder objects, where thispattern reduces the verbosity of the code (for example the PHPUnit Mock Builderor the Doctrine Query Builder),more often it comes at some costs: 破坏了 对象封装 破坏了 装饰器模式 在测试组件中不好做mock 导致提交的diff不好阅读 了解更多请阅读 连贯接口为什么不好，作者 Marco Pivetta. 坏: 1234567891011121314151617181920212223242526272829303132333435363738394041class Car&#123; private $make = 'Honda'; private $model = 'Accord'; private $color = 'white'; public function setMake(string $make): self &#123; $this-&gt;make = $make; // NOTE: Returning this for chaining return $this; &#125; public function setModel(string $model): self &#123; $this-&gt;model = $model; // NOTE: Returning this for chaining return $this; &#125; public function setColor(string $color): self &#123; $this-&gt;color = $color; // NOTE: Returning this for chaining return $this; &#125; public function dump(): void &#123; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color); &#125;&#125;$car = (new Car()) -&gt;setColor('pink') -&gt;setMake('Ford') -&gt;setModel('F-150') -&gt;dump(); 好: 1234567891011121314151617181920212223242526272829303132class Car&#123; private $make = 'Honda'; private $model = 'Accord'; private $color = 'white'; public function setMake(string $make): void &#123; $this-&gt;make = $make; &#125; public function setModel(string $model): void &#123; $this-&gt;model = $model; &#125; public function setColor(string $color): void &#123; $this-&gt;color = $color; &#125; public function dump(): void &#123; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color); &#125;&#125;$car = new Car();$car-&gt;setColor('pink');$car-&gt;setMake('Ford');$car-&gt;setModel('F-150');$car-&gt;dump(); ⬆ 返回顶部 推荐使用 final 类能用时尽量使用 final 关键字: 阻止不受控的继承链 鼓励 组合. 鼓励 单一职责模式. 鼓励开发者用你的公开方法而非通过继承类获取受保护方法的访问权限. 使得在不破坏使用你的类的应用的情况下修改代码成为可能. The only condition is that your class should implement an interface and no other public methods are defined. For more informations you can read the blog post on this topic written by Marco Pivetta (Ocramius). Bad: 1234567891011121314151617final class Car&#123; private $color; public function __construct($color) &#123; $this-&gt;color = $color; &#125; /** * @return string The color of the vehicle */ public function getColor() &#123; return $this-&gt;color; &#125;&#125; Good: 12345678910111213141516171819202122232425interface Vehicle&#123; /** * @return string The color of the vehicle */ public function getColor();&#125;final class Car implements Vehicle&#123; private $color; public function __construct($color) &#123; $this-&gt;color = $color; &#125; /** * &#123;@inheritdoc&#125; */ public function getColor() &#123; return $this-&gt;color; &#125;&#125; ⬆ 返回顶部 SOLIDSOLID 是Michael Feathers推荐的便于记忆的首字母简写，它代表了Robert Martin命名的最重要的五个面对对象编码设计原则 S: 单一职责原则 (SRP) O: 开闭原则 (OCP) L: 里氏替换原则 (LSP) I: 接口隔离原则 (ISP) D: 依赖倒置原则 (DIP) 单一职责原则Single Responsibility Principle (SRP) 正如在Clean Code所述，”修改一个类应该只为一个理由”。人们总是易于用一堆方法塞满一个类，如同我们只能在飞机上只能携带一个行李箱（把所有的东西都塞到箱子里）。这样做的问题是：从概念上这样的类不是高内聚的，并且留下了很多理由去修改它。将你需要修改类的次数降低到最小很重要。这是因为，当有很多方法在类中时，修改其中一处，你很难知晓在代码库中哪些依赖的模块会被影响到。 坏: 123456789101112131415161718192021class UserSettings&#123; private $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function changeSettings(array $settings): void &#123; if ($this-&gt;verifyCredentials()) &#123; // ... &#125; &#125; private function verifyCredentials(): bool &#123; // ... &#125;&#125; 好: 123456789101112131415161718192021222324252627282930313233class UserAuth &#123; private $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function verifyCredentials(): bool &#123; // ... &#125;&#125;class UserSettings &#123; private $user; private $auth; public function __construct(User $user) &#123; $this-&gt;user = $user; $this-&gt;auth = new UserAuth($user); &#125; public function changeSettings(array $settings): void &#123; if ($this-&gt;auth-&gt;verifyCredentials()) &#123; // ... &#125; &#125;&#125; ⬆ 返回顶部 开闭原则Open/Closed Principle (OCP) 正如Bertrand Meyer所述，”软件的工件（ classes, modules, functions 等）应该对扩展开放，对修改关闭。” 然而这句话意味着什么呢？这个原则大体上表示你应该允许在不改变已有代码的情况下增加新的功能 坏: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960abstract class Adapter&#123; protected $name; public function getName(): string &#123; return $this-&gt;name; &#125;&#125;class AjaxAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'ajaxAdapter'; &#125;&#125;class NodeAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'nodeAdapter'; &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch(string $url): Promise &#123; $adapterName = $this-&gt;adapter-&gt;getName(); if ($adapterName === 'ajaxAdapter') &#123; return $this-&gt;makeAjaxCall($url); &#125; elseif ($adapterName === 'httpNodeAdapter') &#123; return $this-&gt;makeHttpCall($url); &#125; &#125; private function makeAjaxCall(string $url): Promise &#123; // request and return promise &#125; private function makeHttpCall(string $url): Promise &#123; // request and return promise &#125;&#125; 好: 1234567891011121314151617181920212223242526272829303132333435interface Adapter&#123; public function request(string $url): Promise;&#125;class AjaxAdapter implements Adapter&#123; public function request(string $url): Promise &#123; // request and return promise &#125;&#125;class NodeAdapter implements Adapter&#123; public function request(string $url): Promise &#123; // request and return promise &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch(string $url): Promise &#123; return $this-&gt;adapter-&gt;request($url); &#125;&#125; ⬆ 返回顶部 里氏替换原则Liskov Substitution Principle (LSP) 这是一个简单的原则，却用了一个不好理解的术语。它的正式定义是“如果S是T的子类型，那么在不改变程序原有既定属性（检查、执行任务等）的前提下，任何T类型的对象都可以使用S类型的对象替代（例如，使用S的对象可以替代T的对象）” 这个定义更难理解:-)。 对这个概念最好的解释是：如果你有一个父类和一个子类，在不改变原有结果正确性的前提下父类和子类可以互换。这个听起来依旧让人有些迷惑，所以让我们来看一个经典的正方形-长方形的例子。从数学上讲，正方形是一种长方形，但是当你的模型通过继承使用了”is-a”的关系时，就不对了。 坏: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Rectangle&#123; protected $width = 0; protected $height = 0; public function setWidth(int $width): void &#123; $this-&gt;width = $width; &#125; public function setHeight(int $height): void &#123; $this-&gt;height = $height; &#125; public function getArea(): int &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Rectangle&#123; public function setWidth(int $width): void &#123; $this-&gt;width = $this-&gt;height = $width; &#125; public function setHeight(int $height): void &#123; $this-&gt;width = $this-&gt;height = $height; &#125;&#125;function printArea(Rectangle $rectangle): void&#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); // BAD: Will return 25 for Square. Should be 20. echo sprintf('%s has area %d.', get_class($rectangle), $rectangle-&gt;getArea()).PHP_EOL;&#125;$rectangles = [new Rectangle(), new Square()];foreach ($rectangles as $rectangle) &#123; printArea($rectangle);&#125; 好: 最好是将这两种四边形分别对待，用一个适合两种类型的更通用子类型来代替。 尽管正方形和长方形看起来很相似，但他们是不同的。正方形更接近菱形，而长方形更接近平行四边形。但他们不是子类型。尽管相似，正方形、长方形、菱形、平行四边形都是有自己属性的不同形状。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface Shape&#123; public function getArea(): int;&#125;class Rectangle implements Shape&#123; private $width = 0; private $height = 0; public function __construct(int $width, int $height) &#123; $this-&gt;width = $width; $this-&gt;height = $height; &#125; public function getArea(): int &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square implements Shape&#123; private $length = 0; public function __construct(int $length) &#123; $this-&gt;length = $length; &#125; public function getArea(): int &#123; return $this-&gt;length ** 2; &#125;&#125;function printArea(Shape $shape): void&#123; echo sprintf('%s has area %d.', get_class($shape), $shape-&gt;getArea()).PHP_EOL;&#125;$shapes = [new Rectangle(4, 5), new Square(5)];foreach ($shapes as $shape) &#123; printArea($shape);&#125; ⬆ 返回顶部 接口隔离原则Interface Segregation Principle (ISP) 接口隔离原则表示：”调用方不应该被强制依赖于他不需要的接口” 有一个清晰的例子来说明示范这条原则。当一个类需要一个大量的设置项，为了方便不会要求调用方去设置大量的选项，因为在通常他们不需要所有的设置项。使设置项可选有助于我们避免产生”胖接口” 坏: 1234567891011121314151617181920212223242526272829303132interface Employee&#123; public function work(): void; public function eat(): void;&#125;class HumanEmployee implements Employee&#123; public function work(): void &#123; // ....working &#125; public function eat(): void &#123; // ...... eating in lunch break &#125;&#125;class RobotEmployee implements Employee&#123; public function work(): void &#123; //.... working much more &#125; public function eat(): void &#123; //.... robot can't eat, but it must implement this method &#125;&#125; 好: 不是每一个工人都是雇员，但是每一个雇员都是一个工人 1234567891011121314151617181920212223242526272829303132333435interface Workable&#123; public function work(): void;&#125;interface Feedable&#123; public function eat(): void;&#125;interface Employee extends Feedable, Workable&#123;&#125;class HumanEmployee implements Employee&#123; public function work(): void &#123; // ....working &#125; public function eat(): void &#123; //.... eating in lunch break &#125;&#125;// robot can only workclass RobotEmployee implements Workable&#123; public function work(): void &#123; // ....working &#125;&#125; ⬆ 返回顶部 依赖倒置原则Dependency Inversion Principle (DIP) 这条原则说明两个基本的要点： 高阶的模块不应该依赖低阶的模块，它们都应该依赖于抽象 抽象不应该依赖于实现，实现应该依赖于抽象 这条起初看起来有点晦涩难懂，但是如果你使用过 PHP 框架（例如 Symfony），你应该见过依赖注入（DI），它是对这个概念的实现。虽然它们不是完全相等的概念，依赖倒置原则使高阶模块与低阶模块的实现细节和创建分离。可以使用依赖注入（DI）这种方式来实现它。最大的好处是它使模块之间解耦。耦合会导致你难于重构，它是一种非常糟糕的的开发模式。 坏: 123456789101112131415161718192021222324252627282930class Employee&#123; public function work(): void &#123; // ....working &#125;&#125;class Robot extends Employee&#123; public function work(): void &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage(): void &#123; $this-&gt;employee-&gt;work(); &#125;&#125; 好: 1234567891011121314151617181920212223242526272829303132333435interface Employee&#123; public function work(): void;&#125;class Human implements Employee&#123; public function work(): void &#123; // ....working &#125;&#125;class Robot implements Employee&#123; public function work(): void &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage(): void &#123; $this-&gt;employee-&gt;work(); &#125;&#125; ⬆ 返回顶部 别写重复代码 (DRY)试着去遵循DRY 原则. 尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。 试想一下，如果你在经营一家餐厅并且你在记录你仓库的进销记录：所有的土豆，洋葱，大蒜，辣椒等。如果你有多个列表来管理进销记录，当你用其中一些土豆做菜时你需要更新所有的列表。如果你只有一个列表的话只有一个地方需要更新。 通常情况下你复制代码是应该有两个或者多个略微不同的逻辑，它们大多数都是一样的，但是由于它们的区别致使你必须有两个或者多个隔离的但大部分相同的方法，移除重复的代码意味着用一个function/module/class创建一个能处理差异的抽象。 用对抽象非常关键，这正是为什么你必须学习遵守在类章节写的SOLID原则，不合理的抽象比复制代码更糟糕，所以务必谨慎！说了这么多，如果你能设计一个合理的抽象，那就这么干！别写重复代码，否则你会发现任何时候当你想修改一个逻辑时你必须修改多个地方。 坏: 12345678910111213141516171819202122232425262728293031function showDeveloperList(array $developers): void&#123; foreach ($developers as $developer) &#123; $expectedSalary = $developer-&gt;calculateExpectedSalary(); $experience = $developer-&gt;getExperience(); $githubLink = $developer-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125;function showManagerList(array $managers): void&#123; foreach ($managers as $manager) &#123; $expectedSalary = $manager-&gt;calculateExpectedSalary(); $experience = $manager-&gt;getExperience(); $githubLink = $manager-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; 好: 123456789101112131415function showList(array $employees): void&#123; foreach ($employees as $employee) &#123; $expectedSalary = $employee-&gt;calculateExpectedSalary(); $experience = $employee-&gt;getExperience(); $githubLink = $employee-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; 极好: 最好让代码紧凑一点 12345678910function showList(array $employees): void&#123; foreach ($employees as $employee) &#123; render([ $employee-&gt;calculateExpectedSalary(), $employee-&gt;getExperience(), $employee-&gt;getGithubLink() ]); &#125;&#125; ⬆ 返回顶部","categories":[{"name":"代码规范","slug":"代码规范","permalink":"http://shiwenyuan.github.io/categories/代码规范/"}],"tags":[{"name":"php","slug":"php","permalink":"http://shiwenyuan.github.io/tags/php/"},{"name":"代码规范","slug":"代码规范","permalink":"http://shiwenyuan.github.io/tags/代码规范/"}]},{"title":"nginx配置https","slug":"nginx配置https","date":"2018-09-11T08:48:05.000Z","updated":"2019-09-10T09:01:47.329Z","comments":true,"path":"post/ck107czta001b8hfybsyexo67.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czta001b8hfybsyexo67.html","excerpt":"","text":"网站https网站https化已是大势所趋，个人blog也都可以把https玩儿起来！ Let’s Encrypt123这个免费、自动化、开放的证书签发服务。它由 ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let&apos;s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。申请 Let&apos;s Encrypt 证书不但免费，还非常简单，虽然每次只有 90 天的有效期，但可以通过脚本定期更新，配好之后一劳永逸。经过一段时间的观望，我也正式启用 Let&apos;s Encrypt 证书了，本文记录本站申请过程和遇到的问题。我没有使用 Let&apos;s Encrypt 官网提供的工具来申请证书，而是用了 [acme.sh](http://https://github.com/Neilpang/acme.sh &quot;acme.sh&quot;) 这个更为小巧的开源工具。以下内容基本按照 acme的说明文档写的，省略了一些我不需要的步骤。 配置验证服务1传统 CA 的验证方式一般是往 admin@youremail.com 发验证邮件，而 Let&apos;s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。 配置前提11. nginx安装了https模块 通过web访问check域名权限步骤1（建立目录或者nginx访问规则）CA认证12345location ^~ /.well-known/acme-challenge/ &#123; # 注：这里的$challenges_dir请替换成你自己的真实目录，如：/home/work/www/challenges/ alias $challenges_dir; try_files $uri =404;&#125; or 12在项目根目录添加.well-known/acme-challengeLet&apos;s Encrypt 用来校验网站权限 步骤二 生成证书1./acme.sh --issue -d diancan.xiaochengxu.phpblog.com.cn --webroot /home/www/xiaochengxu/diancan 步骤三 cp证书到指定位置1234acme.sh --installcert -d www.your-app.com \\ --keypath /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn.key \\ --fullchainpath /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn.key.pem \\ --reloadcmd &quot; /usr/local/nginx/sbin/nginx -s reload&quot; 步骤四 配置nginx1234567891011121314151617181920212223242526server &#123; listen 80; server_name diancan.xiaochengxu.phpblog.com.cn; location / &#123; rewrite ^/(.*)$ https://diancan.xiaochengxu.phpblog.com.cn; &#125;&#125;server &#123; listen 443 ssl; server_name diancan.xiaochengxu.phpblog.com.cn; include /usr/local/nginx/ssl/ssl_params; ssl_certificate /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn/diancan.xiaochengxu.phpblog.com.cn.cer; ssl_certificate_key /usr/local/nginx/ssl/diancan.xiaochengxu.phpblog.com.cn/diancan.xiaochengxu.phpblog.com.cn.key; root /home/www/diancan/xiaochengxu; # 该项要修改为你准备存放相关网页的路径 include /usr/local/nginx/ssl/ssl_headers; location / &#123; try_files $uri $uri/ /index.php?$query_string; index index.php index.html index.htm; &#125; location ~ \\.php$ &#123; include /usr/local/nginx/conf/fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; &#125; &#125; 123456789101112# out /usr/local/nginx/ssl/ssl_headersadd_header Strict-Transport-Security &quot;max-age=15768000; includeSubDomains; preload&quot; always;# out /usr/local/nginx/ssl/ssl_paramsssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_dhparam /usr/local/nginx/ssl/dhparam.pem; # See https://weakdh.org/sysadmin.html for more detailsssl_session_cache shared:SSL:1m;ssl_session_timeout 5m;ssl_prefer_server_ciphers on;ssl_ciphers &quot;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&quot;;dhparam.pem这个文件是我之前就生成好的，生成命令openssl dhparam -out /usr/local/nginx/ssl/dhparam.pem 2048 步骤五 重启nginx查看证书自动更新申请下来的证书有效期只有90天 123在crontab 中添加一条命令0 0 * * * /home/work/opbin/ssl/acme.sh-master/acme.sh --cron --home /home/work/opbin/ssl/acme.sh-master/acme.sh此处就是每天凌晨检查证书 证书会在60天的时候更新 因为acme会记住之前执行的installcert，所以更新完证书之后他会自动重启一下nginx 如果之前运行installcert的时候没有输入reloadcmd,则需要更新之后自己手动重启(这样就没有自动更新的意义了) 通过dns配置check权限手动配置步骤1123456789101112131415161718192021222324252627282930313233343536[work@iZ25ndyf9bxZ acme.sh-master]$ !1019./acme.sh --issue --dns -d *.test.com -d test.com --yes-I-know-dns-manual-mode-enough-go-ahead-please[Tue Sep 11 21:24:56 CST 2018] Creating domain key[Tue Sep 11 21:24:56 CST 2018] The domain key is here: /home/work/.acme.sh/*.test.com/*.test.com.key[Tue Sep 11 21:24:56 CST 2018] Multi domain=&apos;DNS:*.test.com,test.com&apos;[Tue Sep 11 21:24:56 CST 2018] Getting domain auth token for each domain[Tue Sep 11 21:24:59 CST 2018] Getting webroot for domain=&apos;*.test.com&apos;[Tue Sep 11 21:25:00 CST 2018] Getting webroot for domain=&apos;test.com&apos;[Tue Sep 11 21:25:00 CST 2018] Add the following TXT record:[Tue Sep 11 21:25:00 CST 2018] Domain: &apos;_acme-challenge.test.com&apos;[Tue Sep 11 21:25:00 CST 2018] TXT value: &apos;Oe0iBXj3QvUErZOpROldRLx5jpyXbazsX36lkI46C_Y&apos;[Tue Sep 11 21:25:00 CST 2018] Please be aware that you prepend _acme-challenge. before your domain[Tue Sep 11 21:25:00 CST 2018] so the resulting subdomain will be: _acme-challenge.test.com[Tue Sep 11 21:25:00 CST 2018] Add the following TXT record:[Tue Sep 11 21:25:00 CST 2018] Domain: &apos;_acme-challenge.test.com&apos;[Tue Sep 11 21:25:00 CST 2018] TXT value: &apos;qVFtVzCnBsj1omQcdU1m8180rUBO8V5AHDczFUHqsMY&apos;[Tue Sep 11 21:25:00 CST 2018] Please be aware that you prepend _acme-challenge. before your domain[Tue Sep 11 21:25:00 CST 2018] so the resulting subdomain will be: _acme-challenge.test.com[Tue Sep 11 21:25:00 CST 2018] Please add the TXT records to the domains, and re-run with --renew.[Tue Sep 11 21:25:00 CST 2018] Please check log file for more details: /home/work/.acme.sh/acme.sh.log[work@iZ25ndyf9bxZ acme.sh-master]$ ./acme.sh --renew --dns -d *.test.com -d test.com --yes-I-know-dns-manual-mode-enough-go-ahead-please[Tue Sep 11 21:31:18 CST 2018] Renew: &apos;*.test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Multi domain=&apos;DNS:*.test.com,test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Getting domain auth token for each domain[Tue Sep 11 21:31:19 CST 2018] Verifying:*.test.com[Tue Sep 11 21:31:24 CST 2018] Success[Tue Sep 11 21:31:24 CST 2018] Verifying:test.com[Tue Sep 11 21:31:27 CST 2018] Success[Tue Sep 11 21:31:27 CST 2018] Verify finished, start to sign.[Tue Sep 11 21:31:30 CST 2018] Cert success.这个上面说的是需要在dns中添加Domain: &apos;_acme-challenge.test.com&apos;TXT value: &apos;Oe0iBXj3QvUErZOpROldRLx5jpyXbazsX36lkI46C_Y&apos;与 Domain: &apos;_acme-challenge.test.com&apos;TXT value: &apos;qVFtVzCnBsj1omQcdU1m8180rUBO8V5AHDczFUHqsMY&apos; 生效后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[work@iZ25ndyf9bxZ acme.sh-master]$ ./acme.sh --renew --dns -d *.test.com -d test.com --yes-I-know-dns-manual-mode-enough-go-ahead-please[Tue Sep 11 21:31:18 CST 2018] Renew: &apos;*.test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Multi domain=&apos;DNS:*.test.com,DNS:test.com&apos;[Tue Sep 11 21:31:19 CST 2018] Getting domain auth token for each domain[Tue Sep 11 21:31:19 CST 2018] Verifying:*.test.com[Tue Sep 11 21:31:24 CST 2018] Success[Tue Sep 11 21:31:24 CST 2018] Verifying:test.com[Tue Sep 11 21:31:27 CST 2018] Success[Tue Sep 11 21:31:27 CST 2018] Verify finished, start to sign.[Tue Sep 11 21:31:30 CST 2018] Cert success.-----BEGIN CERTIFICATE-----MIIGGDCCBQCgAwIBAgISA/ZIZ/p9WiVXaWSVytreKZWhMA0GCSqGSIb3DQEBCwUAMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQDExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xODA5MTExMjMxMjNaFw0xODEyMTAxMjMxMjNaMBoxGDAWBgNVBAMMDyoueG1hbmxlZ2FsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANnH033ObKrmxX9eLIKqt3kKxcIrcfabqnLJ0nGnjLRaOXco7B3q865OHx4PTKNT89RSAzfJQ5ZSXBY8QqbZAKv8kAzPA7yE0wliJ3rYCesVfAR1CgnOc+jQkTjlZp0q138/GDthgplvaziJUTaGL31Dj338oFU3xmyMxp2JmzUUjD4KkoHPZql5xkQ3pLzxRInWGMfal7f4oHaZQJr1Xwyu5BR/m9G1+PBlmqGsTka75n5i8uchjIFPAuH48c9fEJXLB0TSUfvAdi9HDpVxXsglmiw4eL5JF5ORYIKajAXObt/vl2uNbUHYV5Mr74jr7U/YqAA48X/x9jeHaVNSS/sCAwEAAaOCAyYwggMiMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUhLPM1+fVbGsgfc1CFAsRyu96DUMwHwYDVR0jBBgwFoAUqEpqYwR93brm0Tm3pkVl7/Oo7KEwbwYIKwYBBQUHAQEEYzBhMC4GCCsGAQUFBzABhiJodHRwOi8vb2NzcC5pbnQteDMubGV0c2VuY3J5cHQub3JnMC8GCCsGAQUFBzAChiNodHRwOi8vY2VydC5pbnQteDMubGV0c2VuY3J5cHQub3JnLzApBgNVHREEIjAggg8qLnhtYW5sZWdhbC5jb22CDXhtYW5sZWdhbC5jb20wgf4GA1UdIASB9jCB8zAIBgZngQwBAgEwgeYGCysGAQQBgt8TAQEBMIHWMCYGCCsGAQUFBwIBFhpodHRwOi8vY3BzLmxldHNlbmNyeXB0Lm9yZzCBqwYIKwYBBQUHAgIwgZ4MgZtUaGlzIENlcnRpZmljYXRlIG1heSBvbmx5IGJlIHJlbGllZCB1cG9uIGJ5IFJlbHlpbmcgUGFydGllcyBhbmQgb25seSBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIENlcnRpZmljYXRlIFBvbGljeSBmb3VuZCBhdCBodHRwczovL2xldHNlbmNyeXB0Lm9yZy9yZXBvc2l0b3J5LzCCAQQGCisGAQQB1nkCBAIEgfUEgfIA8AB2AMEWSuCnctLUOS3ICsEHcNTwxJvemRpIQMH6B1Fk9jNgAAABZcjUVQgAAAQDAEcwRQIhALEwfEJJ6OS6IiWZNXZEO/ymIAgZGpD812KCt484URUHAiAW6FCC+6rYa1AFUdT/vFcC3nc4MC9IGHLPOKyiyC8pEAB2AKRQEmkFWhVUXmIRqze8ED9irlV2pF5LFxRFPhsiEGolAAABZcjUVQoAAAQDAEcwRQIgETcbXZ/E5QEB/oRR3xr4B3dZELF4TfnTJJgH7J8YF9gCIQCKq4jXNwJjCAJDz0K81MaoAZ23CImUYJIHCVJTitzphzANBgkqhkiG9w0BAQsFAAOCAQEAPWWEp4v4cvU3c+fgt2a0mQXI5q0gmYQAYaxyXubs3HfxFsFXzroAPH6wvLk/Cw1EciBInnXtvQ+DDfi4FsyhWn598czJ/YEIGiV7ZCi1Ah8NVniST+R3nVIBqhSDCGOpmHdvtfCRCoZErAVFvv0ABsQUSQHkEYmiPwEddhU5srOENzcV4qel/9/bzK3hGlPWB8jLvWQ8uHtSHibGAJsnEG0rMYkFs6pqnzM2EFdRNfm3axDKD8Gai7V5Ezu31iwvgZXjLmhl6xtH3CzkqmPaDarxJtnZLet8SLaEY0inmbhvupOGLUuO+EnAXlxk40z8V1/GtWuyYMz38OwCWcB5fA==-----END CERTIFICATE-----[Tue Sep 11 21:31:30 CST 2018] Your cert is in /home/work/.acme.sh/*.test.com/*.test.com.cer [Tue Sep 11 21:31:30 CST 2018] Your cert key is in /home/work/.acme.sh/*.test.com/*.test.com.key [Tue Sep 11 21:31:30 CST 2018] The intermediate CA cert is in /home/work/.acme.sh/*.test.com/ca.cer [Tue Sep 11 21:31:30 CST 2018] And the full chain certs is there: /home/work/.acme.sh/*.test.com/fullchain.cer [Tue Sep 11 21:31:30 CST 2018] It seems that you are using dns manual mode. please take care: The dns manual mode can not renew automatically, you must issue it again manually. You&apos;d better use the other modes instead.[Tue Sep 11 21:31:30 CST 2018] Call hook error. 生成成功后配置 123456789[work@iZ25ndyf9bxZ acme.sh-master]$ ./acme.sh --installcert -d *.xmanlegal.com \\&gt; --key-file /mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key \\&gt; --fullchain-file /mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key.cer \\&gt; --reloadcmd &quot;echo &quot;Asdf1234&quot; sudo -S /mnt/usr/sbin/nginx -s reload&quot;[Tue Sep 11 21:36:31 CST 2018] Installing key to:/mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key[Tue Sep 11 21:36:31 CST 2018] Installing full chain to:/mnt/usr/ssl/xmanlegal.com/xmanlegal.com.key.cer[Tue Sep 11 21:36:31 CST 2018] Run reload cmd: echo Asdf1234 sudo -S /mnt/usr/sbin/nginx -s reloadAsdf1234 sudo -S /mnt/usr/sbin/nginx -s reload[Tue Sep 11 21:36:31 CST 2018] Reload success 末文证书级别测试相关技术博客","categories":[{"name":"nginx","slug":"nginx","permalink":"http://shiwenyuan.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://shiwenyuan.github.io/tags/nginx/"}]},{"title":"开发自己的composer包","slug":"开发自己的composer包","date":"2018-09-11T03:19:20.000Z","updated":"2019-09-10T09:01:17.144Z","comments":true,"path":"post/ck107czr9000g8hfyuomszq5w.html","link":"","permalink":"http://shiwenyuan.github.io/post/ck107czr9000g8hfyuomszq5w.html","excerpt":"","text":"composer简介1Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。 准备工作 1.一个github账号 2.一个packagist账号 3.一台安装composer的开发机 packagist注册链接 github注册链接 composer注册链接 — # 发布流程 1.首先在github上创建一个项目2.把项目克隆到本地3.进入项目根目录初始化项目123456789101112131415161718192021222324252627282930313233343536373839➜ xdpframework git:(master) composer init Welcome to the Composer config generator This command will guide you through creating your composer.json config.Package name (&lt;vendor&gt;/&lt;name&gt;) [shiwenyuan/xdpframework]: Description []: a xdp frameworkAuthor [北行10000 &lt;13341007105@163.com&gt;, n to skip]: Minimum Stability []: devPackage Type (e.g. library, project, metapackage, composer-plugin) []: License []: MITDefine your dependencies.Would you like to define your dependencies (require) interactively [yes]? Search for a package: Would you like to define your dev dependencies (require-dev) interactively [yes]? Search for a package: &#123; &quot;name&quot;: &quot;shiwenyuan/xdpframework&quot;, &quot;description&quot;: &quot;a xdp framework&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;北行10000&quot;, &quot;email&quot;: &quot;13341007105@163.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123;&#125;&#125;Do you confirm generation [yes]? Would you like the vendor directory added to your .gitignore [yes]? yes 此时目录下回程车一个composer.json文件，文件内容形如 12345678910111213&#123; &quot;name&quot;: &quot;shiwenyuan/xdpframework&quot;, &quot;description&quot;: &quot;a xdp framework&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;北行10000&quot;, &quot;email&quot;: &quot;13341007105@163.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123;&#125;&#125; 4.编写自己的composer包4.1 此处我创建了一个src目录并实现了SayHello类123456➜ xdpframework git:(master) ✗ tree.├── README.md├── composer.json└── src └── SayHello.php 4.2 修改composer.json123456789101112131415161718&#123; &quot;name&quot;: &quot;shiwenyuan/xdpframework&quot;, &quot;description&quot;: &quot;a xdp framework&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;北行10000&quot;, &quot;email&quot;: &quot;13341007105@163.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123;&#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;XdpFrameWork\\\\&quot;: &quot;src/&quot; &#125; &#125;&#125; 4.3 自动加载src目录123456789101112131415161718192021222324在4.2添加了src的加载运行composer install实现自动加载➜ xdpframework git:(master) ✗ composer installLoading composer repositories with package informationUpdating dependencies (including require-dev)Nothing to install or updateGenerating autoload files此时目录中会生成一个vendor 它实现了加载方法➜ xdpframework git:(master) ✗ tree.├── README.md├── composer.json├── src│ └── SayHello.php└── vendor ├── autoload.php └── composer ├── ClassLoader.php ├── LICENSE ├── autoload_classmap.php ├── autoload_namespaces.php ├── autoload_psr4.php ├── autoload_real.php ├── autoload_static.php └── installed.json 4.4 测试结果1234567891011121314创建test.php&lt;?php/** * Created by PhpStorm. * User: shiwenyuan * Date: 2018/8/2 13341007105@163.com * Time: 下午8:56 */require_once __DIR__.&quot;/vendor/autoload.php&quot;;use XdpFrameWork\\SayHello;SayHello::world();命令行中运行➜ xdpframework git:(master) ✗ php test.phphello world 4.5 忽略vendor、composer.json文件12修改.gitignore增加下面两行/vendor/ 4.6提交代码到 github 5. Packagist配置5.1 github关联到Packagist1234561.首先要在Packagist上登录2.点击顶部导航条中的Summit按钮3.在输入框中输入github上的仓库地址，如：https://github.com/shiwenyuan/xdpfarmwork4.然后点击Check按钮5.Packagist会去检测此仓库地址的代码是否符合Composer的Package包的要求6.检测正常的话，会出现Submit按钮，再点击一下Submit按钮，我们的包就提交到Packagist上了 5.2 配置自动同步1231.从Packagist点击个人中心点击profile获取token然后复制2.到github项目首页上点击settings、点击webhooks、点击addwebhook3.把https://packagist.org/api/bitbucket?username=USERNAME&amp;apiToken=TOKEN 复制到Payload URL，在下方输入密码后保存 5.3 打tag测试 引用包1composer require shiwenyuan/xdpframework 注意事项123如果下载不下来到话就换一下镜像composer config -g repo.packagist composer https://packagist.laravel-china.org刚发布上去可能会下载不到，没有同步过来-- 可以等一会在试试看","categories":[{"name":"composer","slug":"composer","permalink":"http://shiwenyuan.github.io/categories/composer/"}],"tags":[{"name":"composer","slug":"composer","permalink":"http://shiwenyuan.github.io/tags/composer/"}]}]}